<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yangyng.github.io</id>
    <title>杨阳的博客</title>
    <updated>2019-06-17T10:07:00.914Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yangyng.github.io"/>
    <link rel="self" href="https://yangyng.github.io/atom.xml"/>
    <subtitle>记录下</subtitle>
    <logo>https://yangyng.github.io/images/avatar.png</logo>
    <icon>https://yangyng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 杨阳的博客</rights>
    <entry>
        <title type="html"><![CDATA[分布式锁及其实现方式]]></title>
        <id>https://yangyng.github.io/post/UzPIBHidO</id>
        <link href="https://yangyng.github.io/post/UzPIBHidO">
        </link>
        <updated>2019-06-17T09:21:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="分布式锁及相关">分布式锁及相关</h3>
<blockquote>
<p>分布式锁的概念 =&gt; 是控制分布式系统之间同步访问共享资源的一种方式</p>
<p>使用场景 =&gt; 在分布式系统中,常常需要协调他们的动作,如果不同的系统或是同一个系统能够的不同主机之间共享了一个或 一组资源,那么访问这些资源的时候,往往需要互斥来防止彼此干扰来保证一致性,在这种情况下,便需要使用到分布式锁</p>
<p>保证可用性 =&gt;</p>
<ul>
<li>==互斥性==,在任意时刻,只有一个客户端能够持有该锁</li>
<li>==不会死锁==(死锁 =&gt; 当两个以上的请求方,双方都在等待对方释放锁,以获取系统资源,但没有一方提前退出时,就成为死锁 ==两个人过独木桥==)</li>
<li>==容错性== 有一个客户端在持有锁的期间崩溃而没有主动解锁,也能保证后续其它客户端能使用该锁</li>
</ul>
</blockquote>
<h4 id="基于redis的分布式锁">基于REDIS的分布式锁</h4>
<h5 id="redission-简介">Redission 简介</h5>
<blockquote>
<p>Redis客户端在基于NIO的Netty框架上,充分的利用了Redis键值数据库提供的一系列优势,在Java实现工具包中常用接口的基础上,未使用这提供了一系列具有分布式特性的常用工具类</p>
<p>支持Redis 单实例 哨兵 Cluster master-slave 等各种部署架构</p>
</blockquote>
<h6 id="1-redis使用lua脚本的-好处">1. redis使用lua脚本的 好处</h6>
<ol>
<li>原子性 Lua脚本是做为一个整体执行的,所以中间不会被其它命令插入</li>
<li>减少网络开销 可以把多条命令一次性打包</li>
</ol>
<h6 id="2-基本思路">2. 基本思路</h6>
<ol>
<li>锁ID作为redis的key value为hash结构 hash的filed为获得锁的客户端ID value为加锁次数</li>
<li>成功新建写入锁的Key对应的Hash的客户端占用锁</li>
<li>==代码待补充==</li>
<li>客户端不断循环重试执行Lua脚本,知道获得锁</li>
<li>锁互斥机制 Lua脚本保证并发情况下加锁的原子性,中间不会被其他命令插入</li>
</ol>
<h6 id="3-可重入锁机制">3. 可重入锁机制</h6>
<blockquote>
<p>如果以获取客户端线程再次获取锁,该客户端线程的锁的次数+1</p>
</blockquote>
<h6 id="4-释放锁机制">4. 释放锁机制</h6>
<p>该客户端的锁的次数-1
如果发现加锁次数是0了,说明这个客户端已经不在持有锁了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql Linux 环境下 使用Docker安装]]></title>
        <id>https://yangyng.github.io/post/YFjckJCA7</id>
        <link href="https://yangyng.github.io/post/YFjckJCA7">
        </link>
        <updated>2019-06-17T09:14:31.000Z</updated>
        <content type="html"><![CDATA[<h5 id="mysql-linux-环境下-使用docker安装">Mysql Linux 环境下 使用Docker安装</h5>
<blockquote>
<pre><code>docker search mysql 用于查询所有可用的mysql镜像
</code></pre>
</blockquote>
<blockquote>
<pre><code>docker images -a 查看下载的镜像
</code></pre>
</blockquote>
<blockquote>
<pre><code>docker ps 查看运行中的 docker 进程
</code></pre>
</blockquote>
<blockquote>
<pre><code>docker run -it --rm --name mysql -e MYSQL_ROOT_PASSWORD=[你的密码] -p 3306:3306 -d mysql 启动mysql进程
</code></pre>
</blockquote>
<blockquote>
<pre><code>docker exec -it mysql bash 进入docker命令行模式
mysql -uroot -p[你的密码] 进入mysql 
</code></pre>
</blockquote>
<blockquote>
<pre><code>select host,user,plugin,authentication_string from mysql.user; 查看用户信息
</code></pre>
<p>如果存在以下记录:</p>
<table>
<thead>
<tr>
<th style="text-align:center">host</th>
<th style="text-align:center">user</th>
<th style="text-align:center">plugin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">root</td>
<td style="text-align:center">caching_sha2_password</td>
</tr>
</tbody>
</table>
<p>执行如下SQL</p>
<pre><code>ALTER user 'root'@'%' IDENTIFIED WITH mysql_native_password BY '[你的密码]'; 
</code></pre>
<p>执行之后的结果如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">host</th>
<th style="text-align:center">user</th>
<th style="text-align:center">plugin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">root</td>
<td style="text-align:center">mysql_native_password</td>
</tr>
</tbody>
</table>
<p>然后执行如下SQL更新配置</p>
<pre><code>FLUSH PRIVILEGES;
</code></pre>
<p>即可正常使用</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Redis 常用配置项]]></title>
        <id>https://yangyng.github.io/post/rcmQSI3Yq</id>
        <link href="https://yangyng.github.io/post/rcmQSI3Yq">
        </link>
        <updated>2019-06-17T09:11:37.000Z</updated>
        <content type="html"><![CDATA[<h4 id="redis-常用配置项">Redis 常用配置项</h4>
<h5 id="设置redis以守护进程方式运行">设置redis以守护进程方式运行</h5>
<blockquote>
<p>daemonize no</p>
</blockquote>
<h5 id="指定端口号">指定端口号</h5>
<blockquote>
<p>port 6379</p>
</blockquote>
<h5 id="设置tcp的backlog">设置tcp的backlog</h5>
<blockquote>
<p>tcp-backlog 511</p>
</blockquote>
<p>**注意: **</p>
<pre><code>backlog 是一个连接队列 
backlog队列总和 = 未完成三次握手队列 + 已完成三次握手队列
在高并发环境下需要一个高的backlog值来避免慢客户端连接问题
Linux内核会将这个值减小到/proc/sys/net/core/somaxconn 的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的
</code></pre>
<h5 id="绑定的主机地址">绑定的主机地址</h5>
<blockquote>
<p>bind 127.0.0.1</p>
</blockquote>
<h5 id="客户端闲置时间关闭连接-单位-秒-设置为-0-则永不关闭">客户端闲置时间关闭连接 单位 秒 设置为 0 则永不关闭</h5>
<blockquote>
<p>timeout 300</p>
</blockquote>
<h5 id="检测客户端网络中断时间间隔-单位-秒-设置为-0-则永不检测-建议设置-60">检测客户端网络中断时间间隔 单位 秒 设置为 0 则永不检测 建议设置 60</h5>
<blockquote>
<p>tcp-keepalive 0</p>
</blockquote>
<h5 id="日志级别-debug-verbose-notice-warning-默认值-verbosewindows-安装时-查看为-notice">日志级别 debug verbose notice warning 默认值 verbose(windows 安装时 查看为  notice)</h5>
<blockquote>
<p>loglevel notice</p>
</blockquote>
<h5 id="日志记录方式-默认为标准输出-如果配置-redis-为守护进程方式运行-在这里有配置为日志记录方式为标准输出-则日志将会发送给-devnull">日志记录方式 默认为标准输出 如果配置 redis 为守护进程方式运行, 在这里有配置为日志记录方式为标准输出 则日志将会发送给 /dev/null</h5>
<blockquote>
<p>logfile stdout</p>
</blockquote>
<h5 id="设置数据库数量-默认值-16-默认当前数据库-0-可以使用-select-dbid-指定数据库id">设置数据库数量 默认值 16 默认当前数据库 0 可以使用  select <dbid> 指定数据库id</h5>
<blockquote>
<p>databases 16</p>
</blockquote>
<h5 id="指定在多长时间内-有多少次更新操作-就将数据同步到数据文件-多条件时-同时成立">指定在多长时间内 有多少次更新操作 就将数据同步到数据文件 多条件时 同时成立</h5>
<blockquote>
<p>save <seconds> <changes></p>
</blockquote>
<blockquote>
<p>示例 save 300 10 <strong>300秒内有10个更改就将数据同步到数据文件</strong></p>
</blockquote>
<h5 id="指定存储到数据库时是否压缩-默认-yes-redis-采用-lzf压缩">指定存储到数据库时是否压缩 默认 yes  redis 采用 LZF压缩</h5>
<blockquote>
<p>rdbcompssion yes</p>
</blockquote>
<h5 id="指定本地数据库文件名">指定本地数据库文件名</h5>
<blockquote>
<p>dbfilename dump.rdb</p>
</blockquote>
<h5 id="本地数据库存放地址">本地数据库存放地址</h5>
<blockquote>
<p>dir ./</p>
</blockquote>
<h5 id="设置本机-slave-服务时-设置master服务的ip地址及端口号在redis启动时自动从master进行数据同步">设置本机 slave 服务时 设置master服务的IP地址及端口号,在redis启动时,自动从master进行数据同步</h5>
<blockquote>
<p>slaveof <masterIP> <masterPort></p>
</blockquote>
<h5 id="master服务设置密码保护时-salve服务连接master-密码">master服务设置密码保护时 salve服务连接master 密码</h5>
<blockquote>
<p>masterauth <master-password></p>
</blockquote>
<h5 id="设置redis连接密码-如果配置连接密码-客户端连接时-需要通过-authpassword提供密码-默认关闭">设置redis连接密码 如果配置连接密码 客户端连接时 需要通过 auth<password>提供密码 默认关闭</h5>
<blockquote>
<p>requirepass foobared</p>
</blockquote>
<h5 id="设置同一时间最大客户端连接数">设置同一时间最大客户端连接数</h5>
<blockquote>
<p>maxclients 128</p>
<p>**注意: **</p>
<p>默认无限制</p>
<p>当客户端连接数达到限制时  redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</p>
</blockquote>
<h5 id="指定redis最大的内存限制">指定redis最大的内存限制</h5>
<blockquote>
<p>maxmemory <bytes></p>
<p>**注意: **</p>
<p>redis 启动时会将数据加载到内存中</p>
<p>达到最大内存后,redis在尝试清除已到期或即将到期的KEY,当方法处理后,仍然达到最大内存设置,将无法再进行写入操作,但仍可以进行读取操作</p>
<p>Redis 新的VM机制 会把key存放内存,value存放在 swap区</p>
</blockquote>
<h5 id="缓存过期策略很重要">缓存过期策略&lt;很重要&gt;</h5>
<blockquote>
<ul>
<li>
<p>volatile-lru 使用LRU算法(最近最少使用) 只对设置了过期时间的key</p>
</li>
<li>
<p>volatile-random 随机移除 只对设置了过期时间的key</p>
</li>
<li>
<p>volarile-ttl 移除ttl值最小以即最近要过期的key</p>
</li>
<li>
<p>allkeys-lru 使用LRU算法 针对所有</p>
</li>
<li>
<p>allkeys-random 随机移除 同上</p>
</li>
<li>
<p>noeviction 永不过期 针对写操作 会返回错误信息</p>
<p>maxmemory-policy noeviction</p>
</li>
</ul>
</blockquote>
<h5 id="是否在每次默认操作后进行日志记录">是否在每次默认操作后进行日志记录</h5>
<blockquote>
<p>redis 在默认情况下是一步的将数据写入磁盘,如果不开启 可能会在断电时导致一段时间内数据丢失</p>
<p>因为redis本身同步数据文件是按上面save条件来同步的,所有的数据会在一段时间内置存在内存中</p>
<p>appendonly no</p>
</blockquote>
<h5 id="指定更新日志文件名">指定更新日志文件名</h5>
<blockquote>
<p>appendfilename appendonly.aof</p>
</blockquote>
<h5 id="指定更新日志条件">指定更新日志条件</h5>
<blockquote>
<p>no 等操作系统进行数据缓存到磁盘(快)</p>
<p>always 每次更新操作后手动调用fsync()将数据写到磁盘(慢 安全)</p>
<p>everysec 每秒同步一次(折中  默认值)</p>
<p>appendfsync everysec</p>
</blockquote>
<h5 id="是否启用虚拟内存机制">是否启用虚拟内存机制</h5>
<blockquote>
<p>默认值 no</p>
<p>VM机制是将数据分页存放</p>
<p>redis将访问量较小的页 及冷数据swap到磁盘上,访问多的页面由磁盘自动换出到内存中</p>
<p>vm-enabled no</p>
</blockquote>
<h5 id="虚拟内存路径-不可多个redis实例共享">虚拟内存路径 不可多个redis实例共享</h5>
<blockquote>
<p>wm-swap-file /temp/redis.swap</p>
</blockquote>
<h5 id="将所有大于-vm-max-memory-的数据存入虚拟内存">将所有大于 vm-max-memory 的数据存入虚拟内存</h5>
<blockquote>
<p>无论 vm-max-memory设置的多小,所有索引数据都是内存存储的(redis的索引数据就是keys)</p>
<p>当vm-max-memory设置为0时,其实就是讲所有value都存放在磁盘 默认值为0</p>
<p>vm-max-memory 0</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用RabbitMQ的一点小总结]]></title>
        <id>https://yangyng.github.io/post/mS0iMd-bJ</id>
        <link href="https://yangyng.github.io/post/mS0iMd-bJ">
        </link>
        <updated>2019-06-17T08:53:52.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="本文主要介绍一些mq的基础概念以及简单的安装使用">本文主要介绍一些MQ的基础概念,以及简单的安装使用</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="本文主要介绍一些mq的基础概念以及简单的安装使用">本文主要介绍一些MQ的基础概念,以及简单的安装使用</h3>
<!-- more -->
<h2 id="rabbit-mq-windows-安装-注意事项">rabbit mq windows 安装 注意事项</h2>
<h3 id="erlang-安装">erlang 安装</h3>
<p><strong>下载地址</strong></p>
<p><a href="http://www.erlang.org/downloads" title="erlang 下载路径">http://www.erlang.org/downloads</a></p>
<p><strong>环境变量配置</strong> <code>ERLANG_HOME 安装路径</code></p>
<p><strong>注意事项</strong>
安装erlang 时注意 一致</p>
<pre><code>C:\Windows\System32\config\systemprofile\.erlang.cookie

C:\Users\用户名\.erlang.cookie
</code></pre>
<hr>
<h3 id="rabbit-mq-安装">rabbit mq 安装</h3>
<p><strong>下载地址</strong></p>
<p><a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.5" title="rabbit mq下载路径">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.5</a></p>
<p>出现失败时</p>
<pre><code>rabbit-service start 启动服务
rabbit-service stop 关闭服务
rabbit-service remove 移除服务
rabbitmq-plugins enable rabbitmq_management 安装页面管理工具
</code></pre>
<hr>
<h3 id="rabbit-mq-使用">rabbit mq 使用</h3>
<pre><code>//获取连接
ConnectionFactory connectionFactory = new ConnectionFactory();
//地址
connectionFactory.setHost(&quot;127.0.0.1&quot;);
//端口号
connectionFactory.setPort(5672);
//用户名
connectionFactory.setUserName(&quot;guest&quot;);
//密码
connectionFactory.setPassword(&quot;guest&quot;);
//获取连接
Connection connection = connectionFactory.getConnection();
//获取通道
Channel channel = connection.getChannel();
//test 队列名称
channel.queueDeclare(&quot;test&quot;,false,false,false,null);
//消息
String message = &quot;this is a test message&quot;;
//发送消息
channel.basicPublish(&quot;&quot;,&quot;test&quot;,null,message.getBytes());
//关闭频道 关闭连接
channel.close();
connection.close();
</code></pre>
<hr>
<h3 id="基本知识简介">基本知识简介</h3>
<ol>
<li>ConnectionFactory 用来获取连接</li>
<li>connection rabbitMq的socket连接,丰庄路socket协议相关部分逻辑</li>
<li>channel用来定义Queue(队列)定义Exchange(交换机)绑定Queue与Exchange 发布消息等操作</li>
</ol>
<h3 id="queue">queue</h3>
<p>rabbitMq的内部对象 用来存储消息</p>
<h4 id="message-acknowledgment">Message acknowledgment</h4>
<p>消息确认机制</p>
<pre><code>mq在收到消息回执时将消息从queue中移除,如果没有收到回执,并检测到消费者的rabbitmq连接断开,会将消息发送给其它消费者(如果存在多个消费者)处理
</code></pre>
<p>开发过程注意</p>
<pre><code>处理完业务逻辑后,没有发送回执给RabbitMQ,会导致Queue中的消息越来越多,消费者重启后出现消息的重复消费问题
</code></pre>
<p>消息的持久化以及消息的事务性</p>
<h4 id="prefetch-count">Prefetch count</h4>
<p>可以设置该参数控制发给每个消费者的消息数.<img src="http://ostest.qiniudn.com/wordpress/wp-content/uploads/2014/02/2014-2-21-9-49-08.png" alt="Prefetch count">比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息。</p>
<h4 id="声明queue">声明Queue</h4>
<ul>
<li>
<p>消费者无法订阅或者获取不存在的Queue中的信息</p>
</li>
<li>
<p>消息被Exchange接受之后,如果没有匹配的Queue,会被丢弃</p>
<p>无论是消费者还是生产者,在使用时,即发送或者接受消息是,去尝试建立消息队列,因为加入客户端去尝试创建一个已经存在的消息队列时,是不会做任何操作,并返回成功.</p>
<p>一个消费者在一个信道中正在监听一个队列的消息时,不允许该消费者在同一个channel中声明其它队列</p>
</li>
</ul>
<p>声明方式 queue.declare</p>
<ul>
<li>
<p><strong>Exclusive 排他队列</strong></p>
<p>该队列仅对首次声明它的连接可见,并在连接断开时自动删除.</p>
<p>1.排他队列是基于连接可见的,同一连接的不同信道可以同时访问同一个连接创建的排他队列</p>
<p>2.一个连接已经声明了一个排他队列,其它连接不允许建立同名的排他队列.</p>
<p>3.即使设置该队列是持久化的,一旦连接关闭或者客户端退出,该排他队列都会被自动删除.</p>
</li>
<li>
<p><strong>Auto-delete 自动删除</strong> 适用于临时队列</p>
</li>
<li>
<p><strong>durable持久化</strong> 在连接断开或者客户端重启后仍会存活</p>
</li>
</ul>
<p><strong>总结</strong></p>
<pre><code>存活周期仅限于当前连接
自动删除的特性
仅能创建一次
</code></pre>
<hr>
<h4 id="路由规则">路由规则</h4>
<ul>
<li><strong>direct 路由规则完全相同 <em>exp:</em> ==</strong></li>
<li><strong>topic 模糊匹配路由规则 <em>exp:</em> like</strong></li>
<li><strong>fanout 发布与订阅方式</strong></li>
</ul>
<h4 id="消费者订阅消息">消费者订阅消息</h4>
<ul>
<li>
<p><strong>basic.consume</strong></p>
<p>订阅某队列中的消息后,channel自动在处理完上一条消息后,接受下一条消息.(同一个channel中消息处理是并行的)除非关闭channel或者取消订阅,否则客户端将会一直接收队列的消息.</p>
</li>
<li>
<p><strong>basic.get</strong></p>
<p>主动获取队列中的消息,但是不可以通过循环调用basic.get来代替basic.consume,basic,get在实际执行的时候,首先consume某一队列,然后检索第一条消息,然后在取消订阅,在高吞吐量的消费者,最好使用第一种方式</p>
</li>
</ul>
<p>多个消费者同时订阅同一个队列,RabbitMQ是采用循环的方式分发消息的,每一条消息只能被一个订阅者接收.消费者在接到消息时,需要给服务器发送一套确认命令,可以在HandelDelivery中调用basic.ack实现,也可以在consume某个队列时,设置autoACK属性为true.如果消费者在接到消息以后还没来得及返回ACK就断开了连接,消息服务器会重传该消息给下一个订阅者,没有订阅者就会存储该消息.</p>
<hr>
<h4 id="生产者消息确认">生产者消息确认</h4>
<ol>
<li>
<p>事务机制</p>
<pre><code> Channel channel = getChannel();

 //将信道置为 publisher confirm 模式
 try {
     channel.txSelect();
     channel.basicPublish(&quot;TEST_DIRECT_EXCHANGE&quot;, &quot;TEST_QUEUE&quot;,
             null, &quot;this is a test msg&quot;.getBytes());
     int result = 1 / 0;
     channel.txCommit();
 } catch (IOException e) {
     channel.txRollback();
     channel.close();
 }
</code></pre>
</li>
<li>
<p>发送方确认机制</p>
<p>Channel channel = getChannel();</p>
<pre><code> //将信道置为 publisher confirm 模式
 channel.confirmSelect();

 channel.basicPublish(&quot;TEST_DIRECT_EXCHANGE&quot;, &quot;TEST_QUEUE&quot;,
         null, &quot;this is a test msg&quot;.getBytes());

 if (channel.waitForConfirms()) {
     System.out.println(&quot;msg send failure %n hhh&quot;);
 }

 channel.close();
</code></pre>
</li>
<li>
<p>批量confirm</p>
</li>
<li>
<p>异步confirm</p>
</li>
</ol>
<p><strong>QPS</strong></p>
<p><strong>异步confirm 支持的峰值最高</strong></p>
<p><strong>均值 异步与批量相差不多 大约是其他两种的五到六倍</strong></p>
<p><strong>均值 普通confirm 比事务方式略高</strong></p>
<h4 id="消息的消费">消息的消费</h4>
<p>对于同一个消息队列 如果拥有多个消费者时 队列收到的消息将以轮询的分发方式发送给消费者</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 使用延迟队列的一点代码]]></title>
        <id>https://yangyng.github.io/post/8doV_ak0A</id>
        <link href="https://yangyng.github.io/post/8doV_ak0A">
        </link>
        <updated>2019-06-17T08:51:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="关于rabbitmq发送延迟队列的实现">关于RabbitMQ发送延迟队列的实现</h4>
<blockquote>
<p>生产者生产消息 =&gt;  死信队列 =&gt; 队列 =&gt;消费者消费队列2中的消息</p>
<p><strong>死信队列</strong> 中的消息经由==过期转发==到 <strong>队列</strong> 中 再由消费者消费</p>
</blockquote>
<p>消息的TTL</p>
<p>死信路由</p>
<h5 id="延迟队列实现代码">延迟队列实现代码</h5>
<pre><code class="language-java">package com.yangkeai.rabbitmq.utils;

import com.alibaba.fastjson.JSON;
import com.yangkeai.common.exception.MyException;
import com.yangkeai.rabbitMQ.config.RabbitMQConfig;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * MQ工具类
 *
 * @author yang yang
 * @create 2018/9/12
 * @since 1.0.0
 */
public class RabbitMQUtils {

    /**
     * 获取连接
     *
     * @return
     */
    public static Connection getConnection() {
        ConnectionFactory factory = new ConnectionFactory();

        factory.setHost(RabbitMQConfig.HOST);
        factory.setPort(RabbitMQConfig.PORT);
        factory.setUsername(RabbitMQConfig.USERNAME);
        factory.setPassword(RabbitMQConfig.PASSWORD);
        factory.setConnectionTimeout(RabbitMQConfig.CONNECTIONTIMEOUT);
        factory.setShutdownTimeout(RabbitMQConfig.SHUTDOWNTIMEOUT);

        try {
            return factory.newConnection();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }

        throw new MQException(&quot;获取连接失败&quot;);
    }

    /**
     * 获取channel对象
     *
     * @return
     */
    public static Channel getChannel() {
        Connection connection = getConnection();
        try {
            return connection.createChannel();
        } catch (IOException e) {
            e.printStackTrace();
        }
        throw new MQException(&quot;创建Channel失败&quot;);
    }

    /**
     * 发送即时消息
     *
     * @param exchangeName 交换机
     * @param queueName    队列名称
     * @param payload      消息体
     */
    public static void send(String exchangeName, String queueName, Object payload) {
        Channel channel = getChannel();
        try {
            channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT);
            channel.queueDeclare(queueName, true, false, false, null);
            channel.queueBind(queueName, exchangeName, queueName);

            channel.confirmSelect();
            channel.basicPublish(exchangeName, queueName, true,
                    new AMQP.BasicProperties
                            .Builder()
                            .contentType(&quot;application/json&quot;)
                            .contentEncoding(&quot;UTF-8&quot;)
                            .build(),
                    JSON.toJSONString(payload).getBytes());

            if (!channel.waitForConfirms()) {
                throw new MQException(&quot;发送消息失败&quot;);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            Connection connection = channel.getConnection();
            closeChannel(channel, connection);
        }
    }

    /**
     * 发送延时消息
     *
     * @param exchangeName  交换机
     * @param queueName     队列名称
     * @param deadQueueName 死信队列名称
     * @param payload       消息体
     * @param delayTime     延时时间
     */
    public static void sendDelay(String exchangeName, String queueName, String deadQueueName, Object payload, Long delayTime) {
        Channel channel = getChannel();
        try {
            //交换器|队列|死信队列 创建与关系绑定
            channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT);

            Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
            arguments.put(&quot;x-max-length&quot;, 10000);
            arguments.put(&quot;x-dead-letter-exchange&quot;, exchangeName);
            arguments.put(&quot;x-dead-letter-routing-key&quot;, queueName);
            channel.queueDeclare(deadQueueName, true, false, false, null);
            channel.queueDeclare(queueName, true, false, false, null);

            channel.queueBind(queueName, exchangeName, queueName);
            channel.queueBind(deadQueueName, exchangeName, deadQueueName);

            //开启发送
            channel.confirmSelect();
            //消息的发送
            channel.basicPublish(exchangeName, queueName, true,
                    new AMQP.BasicProperties
                            .Builder()
                            .contentType(&quot;application/json&quot;)
                            .contentEncoding(&quot;UTF-8&quot;)
                            .expiration(delayTime + &quot;&quot;)
                            .build(),
                    JSON.toJSONString(payload).getBytes());

            if (!channel.waitForConfirms()) {
                throw new MQException(&quot;发送消息失败&quot;);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            Connection connection = channel.getConnection();
            closeChannel(channel, connection);
        }
    }

    /**
     * get方式获取消息 对应的是
     *
     * @param queueName 队列名称
     * @return
     */
    public static String get(String queueName) {
        Channel channel = getChannel();

        try {
            channel.queueDeclare(queueName, true, false, false, null);

            channel.basicQos(1);
            GetResponse getResponse = channel.basicGet(queueName, false);
            if (null != getResponse &amp;&amp; null != getResponse.getEnvelope()) {
                channel.basicAck(getResponse.getEnvelope().getDeliveryTag(), false);
                return new String(getResponse.getBody());
            } else {
                throw new MQException(&quot;获取消息失败&quot;);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            Connection connection = channel.getConnection();
            closeChannel(channel, connection);
        }
        throw new MQException(&quot;获取消息失败&quot;);
    }

    /**
     * 消费者方式获取消息
     *
     * @param queueName 队列名称
     */
    public static void consume(String queueName) {
        final Channel channel = getChannel();

        try {
            channel.queueDeclare(queueName, true, false, false, null);

            channel.basicQos(1);

            Consumer consumer = new DefaultConsumer(channel) {
                @Override
                public void handleDelivery(String consumerTag,
                                           Envelope envelope,
                                           AMQP.BasicProperties properties,
                                           byte[] body)
                        throws IOException {

                    if (null != envelope) {
                        channel.basicAck(envelope.getDeliveryTag(), false);
                        System.out.println(&quot;队列中存储的消息 ：&quot; + new String(body));
                    }
                }
            };
            channel.basicConsume(queueName, consumer);

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                long count = channel.messageCount(queueName);
                if (count &lt;= 0) {
                    Connection connection = channel.getConnection();
                    closeChannel(channel, connection);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 关闭连接
     *
     * @param channel    当前通道
     * @param connection 当前连接
     */
    public static void closeChannel(Channel channel, Connection connection) {
        try {
            if (null != channel) {
                channel.close();
            }
            if (null != connection) {
                connection.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code class="language-java">package com.yangkeai.rabbitmq.config;

import lombok.Builder;
import lombok.Data;

/**
 * rabbitMQ相关的配置
 *
 * @author yang yang
 * @create 2018/9/12
 * @since 1.0.0
 */
@Data
@Builder
public class RabbitMQConfig {

    public static String HOST = &quot;127.0.0.1&quot;;
    public static int PORT = 5672;
    public static String USERNAME = &quot;guest&quot;;
    public static String PASSWORD = &quot;guest&quot;;
    public static int CONNECTIONTIMEOUT = 10_000;
    public static int SHUTDOWNTIMEOUT = 10_000;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA基础总结]]></title>
        <id>https://yangyng.github.io/post/c4zpXbVC3</id>
        <link href="https://yangyng.github.io/post/c4zpXbVC3">
        </link>
        <updated>2019-06-17T03:30:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java基础知识">JAVA基础知识</h2>
<h4 id="1-八种数据类型">1. 八种数据类型</h4>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>包装类</th>
<th>字节</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>double</td>
<td>Double</td>
<td>8位</td>
<td>0.0D</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>4位</td>
<td>0.0F</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>8位</td>
<td>1L</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>4位</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>2位</td>
<td>(short)1</td>
</tr>
<tr>
<td>byte</td>
<td>byte</td>
<td>1位</td>
<td>(byte)0</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>2位</td>
<td>null\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>--</td>
<td>false</td>
</tr>
</tbody>
</table>
<h4 id="2引用数据类型">2.引用数据类型</h4>
<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
<h4 id="3switch是否可以使用string作为参数">3.Switch是否可以使用String作为参数</h4>
<p><strong>Jdk7.0 之前</strong> byte short char int 可以强转</br>
<strong>Jdk7.0 之后</strong> 整形 枚举类型 boolean 字符串都可以</p>
<h4 id="4equals与的区别">4.equals与==的区别</h4>
<blockquote>
<p>== 比较的是对象的地址 </br>
equals 比较的时间对象的内容</p>
</blockquote>
<h4 id="5自动装箱-常量池">5.自动装箱 ,常量池</h4>
<blockquote>
<p>自动装箱: 基本数据类型=&gt;对象类型</p>
<p>自动拆箱: 对象类型=&gt;基本数据类型</p>
</blockquote>
<blockquote>
<p>常量池:Byte Short Integer Long Character 在自动装箱时对于值从-128-127之间的值(共享),会在内存中被重用</p>
</blockquote>
<h4 id="6object有哪些公用方法">6.Object有哪些公用方法</h4>
<ul>
<li>clone()</li>
<li>hashCode()</li>
<li>equals()</li>
<li>notify()</li>
<li>wait()</li>
<li>notifyAll()</li>
<li>getClass()</li>
<li>toString()</li>
<li>finalize()</li>
</ul>
<h4 id="7java的四种引用">7.Java的四种引用</h4>
<ul>
<li>强引用: 使用普遍的引用,内存空间不住了,一般垃圾和回收期绝不会回收它</li>
<li>软引用: 弱引用可用来实现内存敏感的高速缓存,内存空间不足了,就会回收这些对象的内存</li>
<li>弱引用: 具有弱引用的对象,不管当前内存空间足够与否,都会回收它的内存</li>
<li>虚引用: 虚引用并不会决定对象的生命周期.如果一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收器回收</li>
</ul>
<h4 id="8hashcode的作用">8.HashCode的作用</h4>
<p>Java中的hashCode方法就是根据一定的规则将与对象相关的信息(对象的存储地址,对象的字段等)映射成一个数值,这个数值称作为散列值,降低equals的调用,实现存放的值不会重复</p>
<h4 id="9arraylist-linkedlist-vector的作用">9.ArrayList、LinkedList、Vector的作用</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">线程是否安全</th>
<th style="text-align:center">实现方式</th>
<th style="text-align:center">扩容</th>
<th style="text-align:center">适合</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ArrayList</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">自动扩容50%</td>
<td style="text-align:center">查找</td>
</tr>
<tr>
<td style="text-align:center">LinkedList</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center">链表</td>
<td style="text-align:center">删除</td>
<td style="text-align:center">插入</td>
</tr>
<tr>
<td style="text-align:center">Vector</td>
<td style="text-align:center">安全</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">自动扩容100%</td>
<td style="text-align:center">查找</td>
</tr>
</tbody>
</table>
<h4 id="10string-stringbuffer-stringbuilder">10.String StringBuffer StringBuilder</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">线程是否安全</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">对象信息</th>
<th style="text-align:center">适合</th>
<th style="text-align:center">补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">--</td>
<td style="text-align:center">final修饰的字符串常量</td>
<td style="text-align:center">String对象一旦创建之后是不可更改的</td>
<td style="text-align:center">--</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">StringBuffer</td>
<td style="text-align:center">安全</td>
<td style="text-align:center">字符串常量</td>
<td style="text-align:center">对象可变</td>
<td style="text-align:center">适合多线程下字符串缓冲区大量操作</td>
<td style="text-align:center">继承AbstractStringBuilder 容量为16</td>
</tr>
<tr>
<td style="text-align:center">StringBuilder</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center">字符串常量</td>
<td style="text-align:center">对象可变</td>
<td style="text-align:center">适合单线程下字符缓冲区大量操作</td>
<td style="text-align:center">继承AbstractStringBuilder 容量为16</td>
</tr>
</tbody>
</table>
<h4 id="11map-set-list-queue-stack的特点与用法">11.Map Set List Queue Stack的特点与用法</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">实现方式</th>
<th style="text-align:center">线程是否安全</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">是否有序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HashMap</td>
<td style="text-align:center">键值对</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center">不能存储null值</td>
<td style="text-align:center">无序</td>
</tr>
<tr>
<td style="text-align:center">HashTable</td>
<td style="text-align:center">键值对</td>
<td style="text-align:center">安全</td>
<td style="text-align:center">可以存储null值</td>
<td style="text-align:center">无序</td>
</tr>
<tr>
<td style="text-align:center">TreeMap</td>
<td style="text-align:center">键值对</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">有序</td>
</tr>
<tr>
<td style="text-align:center">ArrayList</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LinkedList</td>
<td style="text-align:center">链表</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Vector</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">安全</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Stack</td>
<td style="text-align:center">后进先出的栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="12collection与collections的区别">12.Collection与Collections的区别</h4>
<blockquote>
<p>Collection是各种集合结构的父接口</p>
<p>Collections包含有各种有关集合操作的静态方法</p>
</blockquote>
<h4 id="13trycatchfinally执行">13.try?catch?finally执行</h4>
<blockquote>
<p>finally 中的return也会执行 除非中途遇到JVM退出</p>
</blockquote>
<h4 id="14exception和error">14.Exception和Error</h4>
<blockquote>
<p>两者都是Throwable的子类</p>
<p>Exception 之处了合理的应用程序想要捕获的条件</p>
<p>Error用于只是合理的应用程序不应该视图捕获的严重问题.大多数这样的错误都是异常条件</p>
</blockquote>
<p>OOM中</p>
<ul>
<li>Java heap溢出</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>运行时常量池溢出</li>
<li>方法溢出</li>
</ul>
<p>SOF(StackOverflowError) 当应用程序递归太深发生堆栈溢出时,抛出该错误</p>
<h4 id="15oop的三个特征和含义">15.OOP的三个特征和含义</h4>
<blockquote>
<p>封装: 可见性封装,set get读写,将类的某些特征隐藏在类的内部,不允许外部程序直接访问,而是通过该类提供的方法来实现对隐藏信息的访问和操作</p>
</blockquote>
<blockquote>
<p>继承: 子类继承父类,可以得到父类的全部属性和方法(除了父类中的构造方法),JAVA中的多继承可以通过接口来实现</p>
</blockquote>
<blockquote>
<p>多态: 已是==编译时多态==,另外一种是==运行时多态==,==编译时多态==通过方法的重载来实现,==运行时多态==通过方法的重写来实现</p>
</blockquote>
<h4 id="16重载override和重写overload">16.重载(Override)和重写(Overload)</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">相同</th>
<th style="text-align:center">不同</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">重写(Override)</td>
<td style="text-align:center">子类覆盖父类的方法</br>子类抛出的异常不能超过父类响应方法抛出的异常</br>子类方法的访问级别不能低于弗雷响应方法的访问级别</td>
<td style="text-align:center">返回类型|参数|参数类型|抛出异常</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">重载(Overload)</td>
<td style="text-align:center"></td>
<td style="text-align:center">方法名</td>
<td style="text-align:center">参数个数|参数数量</td>
</tr>
</tbody>
</table>
<h4 id="17interface与abstract类的区别">17.interface与abstract类的区别</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">interface</th>
<th style="text-align:center">abstract</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">构造方法</td>
<td style="text-align:center">--</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">普通成员变量</td>
<td style="text-align:center">--</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">非抽象的普通方法</td>
<td style="text-align:center">--</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">静态方法</td>
<td style="text-align:center">--</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">静态成员变量</td>
<td style="text-align:center">只能切默认为public static final</td>
<td style="text-align:center">任意类型</td>
</tr>
<tr>
<td style="text-align:center">访问类型</td>
<td style="text-align:center">只能为public 默认为public abstract</td>
<td style="text-align:center">public protected</td>
</tr>
<tr>
<td style="text-align:center">继承与实现</td>
<td style="text-align:center">一个类可以实现多个接口</td>
<td style="text-align:center">单继承</td>
</tr>
</tbody>
</table>
<h4 id="18静态内部类和非静态内部类">18.静态内部类和非静态内部类</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">static class</th>
<th style="text-align:center">not static class</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指向外部类的引用</td>
<td style="text-align:center">需要</td>
<td style="text-align:center">不需要</td>
</tr>
<tr>
<td style="text-align:center">描述</td>
<td style="text-align:center">可以访问外部类的静态成员==不能访问外部类的非静态成员==</td>
<td style="text-align:center">访问外部类的静态和非静态成员</td>
</tr>
</tbody>
</table>
<h4 id="19foreach和for">19.foreach和for</h4>
<blockquote>
<p>对于数组 相差不大</p>
</blockquote>
<blockquote>
<p>对于链表 for循环效率比foreach低</p>
</blockquote>
<h4 id="20io与nio">20.IO与NIO</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">IO</th>
<th style="text-align:center">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">是否阻塞</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">非阻塞</td>
</tr>
<tr>
<td style="text-align:center">面向</td>
<td style="text-align:center">流</td>
<td style="text-align:center">缓冲区(块)</td>
</tr>
<tr>
<td style="text-align:center">描述</td>
<td style="text-align:center"></td>
<td style="text-align:center">管道(Channel) 缓冲(Buffer) 选择器(Selector)</td>
</tr>
<tr>
<td style="text-align:center">应用</td>
<td style="text-align:center">少连接 大数据</td>
<td style="text-align:center">多连接 少数据</td>
</tr>
</tbody>
</table>
<h4 id="21xml解析方式">21.XML解析方式</h4>
<blockquote>
<p><strong>DOM:</strong> 将整个XML文档转化成DOM树存放在内存中</p>
</blockquote>
<blockquote>
<p><strong>SAX:</strong> 采用事件驱动,通过事件处理函数实现对XML文档的访问</p>
</blockquote>
]]></content>
    </entry>
</feed>