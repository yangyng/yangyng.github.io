<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yangyng.github.io</id>
    <title>杨阳的博客</title>
    <updated>2019-07-26T10:07:34.098Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yangyng.github.io"/>
    <link rel="self" href="https://yangyng.github.io/atom.xml"/>
    <subtitle>记录下</subtitle>
    <logo>https://yangyng.github.io/images/avatar.png</logo>
    <icon>https://yangyng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 杨阳的博客</rights>
    <entry>
        <title type="html"><![CDATA[Docker 安装Mysql并挂载到主机]]></title>
        <id>https://yangyng.github.io/post/9dILA-L7C</id>
        <link href="https://yangyng.github.io/post/9dILA-L7C">
        </link>
        <updated>2019-07-26T10:06:43.000Z</updated>
        <content type="html"><![CDATA[<h5 id="docker-安装mysql并挂载到主机">Docker 安装Mysql并挂载到主机</h5>
<blockquote>
<p>​	由于使用之前安装的 mysql 在宕机之后数据丢失，所以决定将数据挂载到主机。以此达到数据持久化的目的。</p>
<p>以下是具体的操作过程</p>
</blockquote>
<ol>
<li>
<h6 id="创建持久化的目录">创建持久化的目录</h6>
<p>用于持久化数据</p>
<pre><code>mkdir /src/mysql/data 
</code></pre>
<p>用于存储相应的配置文件</p>
<pre><code>mkdir /src/mysql/config
</code></pre>
<p>创建 mysql 的配置文件 my.cnf 【附录 文末有配置文件】</p>
<pre><code>touch my.cnf 或者 vim my.cnf
</code></pre>
<p>设置目录对应的权限</p>
<pre><code>chmod -R 777 /src/mysql
</code></pre>
</li>
<li>
<h6 id="创建对应的容器">创建对应的容器</h6>
</li>
</ol>
<pre><code> docker run 
 --name mysql5.7 
 --restart always 
 --privileged=true 
 -p 3306:3306 
 -v /src/tool/mysql/config/my.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf 
 -v /src/tool/mysql/data:/var/lib/mysql 
 -e MYSQL_USER=&quot;yangkei_blog&quot; 
 -e MYSQL_PASSWORD=&quot;yangkeiblog0329..&quot; 
 -e MYSQL_ROOT_PASSWORD=&quot;wuliao..0329&quot; 
 -d mysql:5.7
 
 -p 端口映射，格式为：主机(宿主)端口:容器端口
 --restart=always 设置随服务启动而启动容器
 --name 命名容器名称
 -v 设置挂载点，格式为：主机（宿主）目录：容器目录
 -e 设置环境变量
 -d 后台运行容器，并返回容器ID
 --privileged=true 使用该参数，container内的root拥有真正的root权限
 
　备注: 对于已经运行但没设置随docker服务的启动而启动容器的可以执行如下命令
　　　　docker update --restart=always 容器名
</code></pre>
<ol start="3">
<li>
<h6 id="查看容器状态">查看容器状态</h6>
</li>
</ol>
<pre><code>docker ps
-a 查看所有状态的容器
</code></pre>
<p><strong>附录</strong></p>
<pre><code>[client]
default-character-set=utf8

[mysql]
default-character-set=utf8

[mysqld]
character-set-server=utf8
default_authentication_plugin=mysql_native_password
skip-name-resolve

bind-address = 0.0.0.0
server-id = 1 #表示是本机的序号为1,一般来讲就是master的意思
# socket = /tmp/mysql.sock    -- 启动的sock文件
# log-bin = /data/mysql-bin
# basedir = /usr/local/mysql
# datadir = /data/
# pid-file = /data/mysql.pid
# user = mysql
# 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，
# 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求
# skip-networking

back_log = 600
# MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，
# 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。
# 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，
# 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。
# 另外，这值（back_log）限于您的操作系统对到来的TCP/IP连接的侦听队列的大小。
# 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。

max_connections = 1000
# MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过'conn%'通配符查看当前状态的连接数量，以定夺该值的大小。

max_connect_errors = 6000
# 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。

open_files_limit = 65535
# MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，
# 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。

table_open_cache = 128
# MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64
# 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)；
# 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上

max_allowed_packet = 4M
# 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。
# 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。

binlog_cache_size = 1M
# 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K

max_heap_table_size = 8M
# 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变

tmp_table_size = 16M
# MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。
# 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。
# 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果

read_buffer_size = 2M
# MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。
# 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能

read_rnd_buffer_size = 8M
# MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，
# MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大

sort_buffer_size = 8M
# MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。
# 如果不能，可以尝试增加sort_buffer_size变量的大小

join_buffer_size = 8M
# 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享

thread_cache_size = 8
# 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，
# 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，
# 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)
# 根据物理内存设置规则如下：
# 1G  —&gt; 8
# 2G  —&gt; 16
# 3G  —&gt; 32
# 大于3G  —&gt; 64

query_cache_size = 8M
#MySQL的查询缓冲大小（从4.0.1开始，MySQL提供了查询缓冲机制）使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，
# 今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。
# 通过检查状态值'Qcache_%'，可以知道query_cache_size设置是否合理：如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，
# 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，
# 这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲

query_cache_limit = 2M
#指定单个查询能够使用的缓冲区大小，默认1M

key_buffer_size = 4M
#指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，
# 系统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态值Key_read_requests和Key_reads，
# 可以知道key_buffer_size设置是否合理。比例key_reads/key_read_requests应该尽可能的低，
# 至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE 'key_read%'获得)。注意：该参数值设置的过大反而会是服务器整体效率降低

ft_min_word_len = 4
# 分词词汇最小长度，默认4

transaction_isolation = REPEATABLE-READ
# MySQL支持4种事务隔离级别，他们分别是：
# READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.
# 如没有指定，MySQL默认采用的是REPEATABLE-READ，ORACLE默认的是READ-COMMITTED

#log_bin = mysql-bin
binlog_format = mixed
expire_logs_days = 30 #超过30天的binlog删除

#log_error = /data/mysql/mysql-error.log #错误日志路径
slow_query_log = 1
long_query_time = 1 #慢查询时间 超过1秒则为慢查询
#slow_query_log_file = /data/mysql/mysql-slow.log

performance_schema = 0
explicit_defaults_for_timestamp

#lower_case_table_names = 1 #不区分大小写

skip-external-locking #MySQL选项以避免外部锁定。该选项默认开启

default-storage-engine = InnoDB #默认存储引擎

innodb_file_per_table = 1
# InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间
# 独立表空间优点：
# 1．每个表都有自已独立的表空间。
# 2．每个表的数据和索引都会存在自已的表空间中。
# 3．可以实现单表在不同的数据库中移动。
# 4．空间可以回收（除drop table操作处，表空不能自已回收）
# 缺点：
# 单表增加过大，如超过100G
# 结论：
# 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files

innodb_open_files = 500
# 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300

innodb_buffer_pool_size = 64M
# InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.
# 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.
# 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%
# 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.
# 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,
# 所以不要设置的太高.

innodb_write_io_threads = 4
innodb_read_io_threads = 4
# innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4
# 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64

innodb_thread_concurrency = 0
# 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量

innodb_purge_threads = 1
# InnoDB中的清除操作是一类定期回收无用数据的操作。在之前的几个版本中，清除操作是主线程的一部分，这意味着运行时它可能会堵塞其它的数据库操作。
# 从MySQL5.5.X版本开始，该操作运行于独立的线程中,并支持更多的并发数。用户可通过设置innodb_purge_threads配置参数来选择清除操作是否使用单
# 独线程,默认情况下参数设置为0(不使用单独线程),设置为 1 时表示使用单独的清除线程。建议为1

innodb_flush_log_at_trx_commit = 2
# 0：如果innodb_flush_log_at_trx_commit的值为0,log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作（执行是由mysql的master thread线程来执行的。
# 主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件(REDO LOG)中。不论事务是否已经提交）默认的日志文件是ib_logfile0,ib_logfile1
# 1：当设为默认值1的时候，每次提交事务的时候，都会将log buffer刷写到日志。
# 2：如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。
# 每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘
# 默认值1是为了保证完整的ACID。当然，你可以将这个配置项设为1以外的值来换取更高的性能，但是在系统崩溃的时候，你将会丢失1秒的数据。
# 设为0的话，mysqld进程崩溃的时候，就会丢失最后1秒的事务。设为2,只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。
# 总结
# 设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能

innodb_log_buffer_size = 2M
# 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间

innodb_log_file_size = 32M
# 此参数确定数据日志文件的大小，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间

innodb_log_files_in_group = 3
# 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3

innodb_max_dirty_pages_pct = 90
# innodb主线程刷新缓存池中的数据，使脏数据比例小于90%

innodb_lock_wait_timeout = 120 
# InnoDB事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用LOCK TABLES语句注意到锁定设置。默认值是50秒

bulk_insert_buffer_size = 8M
# 批量插入缓存大小， 这个参数是针对MyISAM存储引擎来说的。适用于在一次性插入100-1000+条记录时， 提高效率。默认值是8M。可以针对数据量的大小，翻倍增加。

myisam_sort_buffer_size = 8M
# MyISAM设置恢复表之时使用的缓冲区的尺寸，当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区

myisam_max_sort_file_size = 10G
# 如果临时文件会变得超过索引，不要使用快速排序索引方法来创建一个索引。注释：这个参数以字节的形式给出

myisam_repair_threads = 1
# 如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内) 

interactive_timeout = 28800
# 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。默认值：28800秒（8小时）

wait_timeout = 28800
# 服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，
# 取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时）
# MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，
# 应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，
# 最终肯定会达到MySQL Server的连接上限数，这会报'too many connections'的错误。对于wait_timeout的值设定，应该根据系统的运行情况来判断。
# 在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，
# 可以进行适当的调整小些。要同时设置interactive_timeout和wait_timeout才会生效。

[mysqldump]
quick
max_allowed_packet = 16M #服务器发送和接受的最大包长度

[myisamchk]
key_buffer_size = 8M
sort_buffer_size = 8M
read_buffer = 4M
write_buffer = 4M
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql 基础知识总结]]></title>
        <id>https://yangyng.github.io/post/o7CPRhvbQ</id>
        <link href="https://yangyng.github.io/post/o7CPRhvbQ">
        </link>
        <updated>2019-07-15T07:44:25.000Z</updated>
        <content type="html"><![CDATA[<h4 id="mysql-存储过程">mysql 存储过程</h4>
<h6 id="什么是存储过程">什么是存储过程</h6>
<p>为以后使用而创建的一条或者多条SQL语句的集合，可视为批文件，但其作用不仅限于批处理。可以用来处理一些复杂的重复的操作。</p>
<h6 id="为什么要使用存储过程">为什么要使用存储过程</h6>
<ul>
<li>简单 简化复杂的操作</li>
<li>安全</li>
<li>高性能 使用存储过程比使用简单的SQL要更加的快</li>
</ul>
<h6 id="新建存储过程">新建存储过程</h6>
<pre><code class="language-mysql">-- 创建存储过程 IN 参数 sel_date 选中时间 OUT 返回值 reg_user_nums 选中天注册的用户数量
CREATE PROCEDURE US_USER_SELECT_DAY ( IN sel_date VARCHAR ( 13 ) ,OUT US_USER_NUMS int(10) ) BEGIN
SELECT
-- 将统计结果赋值给返回值
	COUNT( REG_ID ) INTO  US_USER_NUMS FROM US_USER 
WHERE
	DATE( REG_DATE ) = DATE( sel_date );
END;
</code></pre>
<p>在以上示例中 可以看到 存储过程可以传递参数【sel_date】，可以定义返回值【US_USER_NUMS】</p>
<h6 id="删除存储过程">删除存储过程</h6>
<pre><code class="language-mysql">-- 当存在该存储过程时 删除
DROP PROCEDURE IF EXISTS US_USER_SELECT_DAY;
</code></pre>
<h6 id="执行存储过程">执行存储过程</h6>
<pre><code class="language-mysql">-- 执行存储过程
CALL US_USER_SELECT_DAY ( '2019-6-27', @total );
-- 获取返回值
SELECT @total;
</code></pre>
<p>其中【@total】为以上定义的返回值 【'2019-6-27'】为参数值 筛选时间</p>
<h6 id="查看存储过程信息">查看存储过程信息</h6>
<pre><code class="language-mysql">-- 查看存储过程的详细信息
SHOW PROCEDURE STATUS LIKE 'US_USER_SELECT_DAY%' 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA 网络编程之 Socket]]></title>
        <id>https://yangyng.github.io/post/yhwAqiPTR</id>
        <link href="https://yangyng.github.io/post/yhwAqiPTR">
        </link>
        <updated>2019-06-27T08:57:40.000Z</updated>
        <content type="html"><![CDATA[<h5 id="java-网络编程之-socket">JAVA 网络编程之 Socket</h5>
<h6 id="socket-套接字">Socket （套接字）</h6>
<blockquote>
<p>用于描述IP地址和端口</p>
<p>ServerSocket 常用于服务器端，Socket是建立网络连接时使用的。</p>
<p>连接成功时，客户端与服务端都会产生一个Socket实例，通过对这个Socket的操作，来实现所需的会话。</p>
<p>对于一个网络连接来说，套接字是平等的，并没有差别，不因为在服务器端或在客户端而产生不同级别。不管是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的。</p>
</blockquote>
<h6 id="socket-api">Socket  API</h6>
<blockquote>
<ul>
<li>accept()  用于产生“阻塞” 知道接收到一个连接，并且返回一个客户端的Socket实例对象。</li>
<li>getInputStream() 获得网络连接并返回一个 InputStream对象 inputStream的关闭会导致Socket的关闭</li>
<li>getOutputStream() 连接的另一端将得到输入，同时返回一个OutputStream对象实例</li>
</ul>
</blockquote>
<h5 id="tcp-编程">TCP 编程</h5>
<h6 id="服务端实现步骤">服务端实现步骤</h6>
<blockquote>
<ol>
<li>创建ServerSocket 对象，绑定监听端口</li>
<li>调用accept() 方法监听客户端请求</li>
<li>通过输入流读取客户端发送的请求信息</li>
<li>通过输出流向客户端发送响应信息</li>
<li>关闭相应资源</li>
</ol>
</blockquote>
<pre><code class="language-java">	/**
     * 创建线程池
     */
    private static ExecutorService threadPool = Executors.newFixedThreadPool(20);

    /**
     * 创建服务端
     * @throws IOException
     */
    private static void createServer() throws IOException {
        while (true) {
            //监听端口 6000
            ServerSocket serverSocket = new ServerSocket(55533);
            //获取客户端信息
            Socket accept = serverSocket.accept();
            //是否启用心跳机制
            accept.getKeepAlive();
            //客户端与服务端建立连接时 新建任务 并提交该任务到线程池
            if (null != accept) {
                Runnable task = new Runnable() {
                    @Override
                    public void run() {
                        InputStream inputStream = null;
                        StringBuilder sb = new StringBuilder();
                        try {
                            inputStream = accept.getInputStream();
                            byte[] bytes = new byte[1024];
                            int len;
                            while ((len = inputStream.read(bytes)) != -1) {
                                //注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8
                                sb.append(new String(bytes, 0, len, &quot;UTF-8&quot;));
                            }
                        } catch (IOException e) {
                            e.printStackTrace();
                        }

                        System.out.println(&quot;我看到你了！！&quot;);
                        System.out.println(&quot;通话内容是: &quot; + sb.toString());
                        System.out.println(&quot;端口 &quot; + accept.getPort());
                        System.out.println(&quot;IP 地址 &quot; + JSON.toJSONString(accept.getInetAddress()));

                        OutputStream outputStream = null;
                        try {
                            outputStream = accept.getOutputStream();
                            outputStream.write(&quot;老铁 我收到你消息了！！&quot;.getBytes(&quot;UTF-8&quot;));
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                };
                threadPool.submit(task);
            }
        }
    }
</code></pre>
<p>==注意： == 在以上的代码中所有的 OutputStream 与 InputStream都没有关闭，因为流的关闭会导致 Socket 的关闭</p>
<h6 id="客户端实现步骤">客户端实现步骤</h6>
<blockquote>
<ol>
<li>创建Socket对象,指明需要连接的服务器的地址和短括号</li>
<li>连接建立后,通过输出流向服务端发送请求信息</li>
<li>通过输入流读取服务器响应的信息</li>
<li>关闭相应资源</li>
</ol>
</blockquote>
<pre><code class="language-java">/**
     * 测试
     * @param args
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        int port = 55533;
        String host = &quot;127.0.0.1&quot;;
        String msg =&quot;我给你发消息了 老铁!!&quot;;
        sendMsg(port, host, msg);
    }

    /**
     * 发送消息
     * @param port
     * @param host
     * @param msg
     */
    private static void sendMsg(int port, String host, String msg) {
        Socket socket = null;
        OutputStream outputStream = null;
        InputStream inputStream = null;
        try {
            socket = new Socket(host, port);
            outputStream = socket.getOutputStream();

            if (StringUtils.isEmpty(msg)) {
                msg = &quot;&quot;;
            }
            outputStream.write(msg.getBytes(&quot;UTF-8&quot;));
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if(null!=socket){
                    socket.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
            }
        }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Zookeeper 安装及使用]]></title>
        <id>https://yangyng.github.io/post/irGtrHitc</id>
        <link href="https://yangyng.github.io/post/irGtrHitc">
        </link>
        <updated>2019-06-25T10:11:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="zookeeper-安装及使用">Zookeeper 安装及使用</h3>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/">下载地址</a></p>
<p>使用 wget <a href="https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/">https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/</a> 下载安装包</p>
<pre><code>tar -zxvf  zookeeper.tar.gz 解压
</code></pre>
<p>进入到 zookeeper 下conf 目录
<img src="https://yangyng.github.io/post-images/1561458117644.png" alt=""></p>
<pre><code>cp zoo_sample.cfg zoo.cfg //复制配置文件
</code></pre>
<p>编辑配置文件</p>
<pre><code>vi zoo.cfg

# 存储内存中数据库快照的位置，顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存到这个目录里
dataDir=/user/local/zookeeper/data 
# 日志存储地址 该参数如果不设置 日志会默认打印到dataDir
dataLogDir=/user/local/zookeeper/logs 
# 基本事件单元，以毫秒为单位，这个时间作为 Zookeeper 服务器之间或客户端之间维持心跳的时间间隔
tickTime=2000
# 这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求
clientPort=2181
# 这个配置项是用来配置 Zookeeper 接受客户端初始化连接时最长能忍受多少个心跳时间间隔
当已经超过 10 个心跳的时间也就是（ticktime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败，总的时间长度就是：10*2000 = 20s
initLimit=10
# 这个配置项表示 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是：5*2000 = 10s
syncLimit=5
# A：表示这是第几号服务器 B：服务器的 IP 地址 C：服务器与集群中的 Leader 服务器交换信息的端口 D：一旦集群中的 Leader 服务器挂了，需要一个端口重新进行选举，选出一个新的 Leader
2181：对外提供端口 2888：内部同步端口 3888：节点挂了，选举端口
server.A = B:C:D
</code></pre>
<p>zookeeper 命令</p>
<pre><code># 启动
./bin/zkServer.sh  start 
# 后台启动
./bin/zkServer.sh start-foreground
# 查看状态
./bin/zkServer.sh  status 
# 连接
./bin/zkCli.sh
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建VUE环境]]></title>
        <id>https://yangyng.github.io/post/xZU_F4iZ3</id>
        <link href="https://yangyng.github.io/post/xZU_F4iZ3">
        </link>
        <updated>2019-06-18T09:59:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="node-及-vue-环境搭建">NODE 及 VUE 环境搭建</h2>
<p><a href="https://nodejs.org/dist/v10.15.0/node-v10.15.0-x64.msi/">NODE 下载地址</a></p>
<p>安装成功后 <code>node -v</code> 查看版本</p>
<p>更换镜像为淘宝源</p>
<pre><code>npm config set registry https://registry.npm.taobao.org
</code></pre>
<p>使用 cnpm</p>
<pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre>
<p>安装vue脚手架</p>
<pre><code>cnpm install -g vue-cli
</code></pre>
<p>创建VUE项目</p>
<pre><code>vue init webpack 项目名称
</code></pre>
<p>VUE 项目启动</p>
<pre><code>npm run dev
</code></pre>
<p>VUE 项目打包</p>
<pre><code>npm run build
</code></pre>
<p>项目部署</p>
<p>找到 项目文件夹中的 dist 放到tomcat webapp中即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP与HTTP的简单总结]]></title>
        <id>https://yangyng.github.io/post/Yu8MetoSD</id>
        <link href="https://yangyng.github.io/post/Yu8MetoSD">
        </link>
        <updated>2019-06-18T09:55:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="tcp">TCP</h3>
<blockquote>
<p>TCP 是面向连接的（就好像是打电话一样，通话之前需要先拨号建立连接，通话结束后要挂机释放连接）</p>
<p>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）</p>
<p>TCP提供可靠支付的服务。通过TCP连接传送的数据，无差错，不丢失，不重复，并且按顺序到达</p>
<p>TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。</p>
<p>TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据</p>
<p>通过字节流。TCP中的流（stream）指的是流入进程或者从进程流出的字节序列
&quot;面向字节流&quot;的含义是: 虽然应用程序和TCP的交互是一次一个数据块（大小不等）
但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流</p>
</blockquote>
<p><strong>建立连接的过程</strong></p>
<ol>
<li>第一次握手:客户端发送SYN包（seq=x）到服务器，等待服务器确认</li>
<li>第二次握手:服务器收到SYN包，生成ACK包 : （ack=x+1）,同时自己也发送一个SYN包（seq=y），及SYN+ACK包</li>
<li>第三次握手: 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=y+1）, 此包发送完毕，完成三次握手</li>
</ol>
<p><strong>为什么要3次握手</strong></p>
<p>三次握手最主要的目的就是双方确认呢自己与对方的发送与接收是正常的</p>
<p><strong>终止连接的过程</strong></p>
<ol>
<li>第一次挥手: 主动广播发送一个FIN,用来关闭主动方到被动关闭方的数据连接</li>
<li>第二次挥手: 被动关闭防收到FIN包后,发送一个ACK给对方,确认序号为收到序号+1</li>
<li>第三次挥手: 服务器将最后的数据发送完毕后,就像客户端发送连接释放保温,被动关闭方发送一个FIN,用来关闭被动方到主动方的数据传送</li>
<li>第四次挥手: 主动关闭方收到FIN后,发送ACK给被动关闭方,确认序号为收到序号+1,然后主动关闭方进入TIME-WAIT(时间等待)状态,必须经过2*MSL(最长报文段寿命)的时间才进入CLOSED状态</li>
</ol>
<p><strong>导致连接复位RST的原因</strong></p>
<p>访问不存在的端口,或者端口处于TIME_WAIT阶段</p>
<p>连接已关闭,比如接受数据方提前强制关闭连接或连接已自然关闭,再收到数据会返回RST</p>
<p>建立连接超时,主动建立连接方发出SYN到接收到SYN的时间间隔超时,会发出RST拒绝进一步发送数据</p>
<p>可靠传输保证机制</p>
<ol>
<li>最适合切割,应用数据被切割称TCP认为是最合适发送的数据块</li>
<li>超时重传,当TCP发出一个段后,它启动一个定时器,等待目的端确认收到这个报文段.如果不能及时收到一个确认,将重发这个报文段</li>
<li>校验和,TCP将保持它首部和数据的校验和.这是一个端到端的校验和,目的是检测数据在传输过程中的任何变化.如果收到段的校验和有差错,TCP将丢弃这个报文段和不确认收到此报文段</li>
<li>去重,TCP的接收端会丢弃重复的数据</li>
<li>流量控制,TCP连接的每一方都有固定大小的缓冲空间,TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据.当接收方来不及处理发送方的数据,能提示发送方降低发送的速率,防止包丢失.TCP使用的流量控制协议是可变大小的滑动窗口协议(TCP利用滑动窗口实现流量控制)</li>
<li>拥塞控制,当网络阻塞时,减少数据的发送</li>
<li>停止等待ARQ协议(stop and wait)也是为了实现可靠传输的,它的基本原理就是每发完一个分组就停止发送,等到对方确认.在收到确认后在发下一个分组</li>
</ol>
<h3 id="http">HTTP</h3>
<blockquote>
<p>超文本传输协议是应用层协议.HTTP是一种请求/响应式的协议,及一个客户端与服务器建立连接后,向服务器发送一个请求;服务器接到请求后,给与响应的响应信息</p>
</blockquote>
<h5 id="请求行">请求行</h5>
<ol>
<li>协议版本</li>
<li>请求方法
<ul>
<li>GET 从服务器中读取某个资源时 传递参数长度受限制</li>
<li>POST 向服务器提交数据 x3w 方式 参数大小受限</li>
<li>PUT 用于向指定的URL传送更新资源 通常是幂等的</li>
<li>DELETE 用来删除某一个资源</li>
<li>HEAD OPTIONS TRACE CONNECt</li>
</ul>
</li>
<li>URL 统一资源定位符,对可以从互联网上得到的位置和访问方法的一种简介的标识,是互联网上标准资源的地址</li>
</ol>
<h5 id="请求头部">请求头部</h5>
<p>请求头部由关键字/兼职对组成,每行一对,关键字和值用英文&quot;:&quot;分割.请求头部通知服务器有关于客户端请求的信息</p>
<p><strong>常见请求头</strong></p>
<ul>
<li>User-Agent 产生请求的浏览器类型</li>
<li>Accept-Encoding 客户端可接受的编码压缩格式</li>
<li>Accept-Language 客户端可接受的自然语言</li>
<li>Accept-Charset 可接受的应答的字符集</li>
<li>Host 请求的主机名,允许多个域名同处一个IP地址,及虚拟主机</li>
<li>Cookie  存储于客户端扩展字段,想统一域名的服务端发送属于该域的cookie</li>
<li>Connection Http1.1 之后 close-短连接  keepalive 长连接</li>
</ul>
<h5 id="响应报文">响应报文</h5>
<p><strong>状态行</strong></p>
<ol>
<li>协议版本</li>
<li>状态码
<ul>
<li>1xx 标识服务器已接受了客户端请求,客户端可继续发送请求</li>
<li>2xx 表示服务器已成功接收到请求并进行处理</li>
<li>3xx 表示服务器要求客户端重定向</li>
<li>4xx 表示客户端的请求有非法内容</li>
<li>5xx 表示服务器未能正常处理客户端的请求而出现意外错误</li>
</ul>
</li>
<li>响应头部 Location 响应报文域用于重定向接受者到哦一个新的位置 Server 响应报文域包含了服务器用来处理请求的软件信息及其版本</li>
</ol>
<p>HTTP 2.0 与HTTP 1.0 的区别</p>
<ul>
<li>2/采用二进制格式而非文本格式</li>
<li>2/是完全多路复用的,而非有序并阻塞的-只需要一个连接即可实现并行</li>
<li>2/是用来包头铺压缩,降低了开销</li>
<li>2/支持双向通讯</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx的安装与简单的使用]]></title>
        <id>https://yangyng.github.io/post/MHozHIZbh</id>
        <link href="https://yangyng.github.io/post/MHozHIZbh">
        </link>
        <updated>2019-06-18T09:53:30.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<h3 id="1-环境安装">1. 环境安装</h3>
<p>1.1 安装nginx需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc</p>
<blockquote>
<p>yum install gcc-c++</p>
</blockquote>
<p>1.2 PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库</p>
<blockquote>
<p>yum install -y pcre pcre-devel</p>
</blockquote>
<p>1.3 zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。</p>
<blockquote>
<p>yum install -y zlib zlib-devel</p>
</blockquote>
<p>1.4 OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。</p>
<h5 id="nginx不仅支持http协议还支持https即在ssl协议上传输http所以需要在linux安装openssl库">nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库</h5>
<blockquote>
<p>yum install -y openssl openssl-devel</p>
</blockquote>
<h3 id="2-编译安装">2. 编译安装</h3>
<h4 id="21-将nginx-180targz拷贝至linux服务器">2.1 将nginx-1.8.0.tar.gz拷贝至linux服务器。</h4>
<h4 id="22-解压">2.2 解压</h4>
<blockquote>
<p>tar -zxvf nginx-1.8.0.tar.gz
cd nginx-1.8.0</p>
</blockquote>
<h4 id="23-编译">2.3 编译</h4>
<pre><code> ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module
make 
make install 
</code></pre>
<h3 id="3-启动重启">3. 启动重启</h3>
<h4 id="31-启动">3.1 启动</h4>
<pre><code>cd /usr/local/nginx/sbin/
./nginx
// 执行./nginx启动nginx，这里可以-c指定加载的nginx配置文件，如下：./nginx -c /usr/local/nginx/conf/nginx.conf.如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件，此文件的地址也可以在编译安装nginx时指定./configure的参数（--conf-path= 指向配置文件（nginx.conf））
</code></pre>
<h4 id="32-停止nginx">3.2 停止nginx</h4>
<h5 id="321-快速停止">3.2.1 快速停止</h5>
<pre><code>cd /usr/local/nginx/sbin
./nginx -s stop
//此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。
</code></pre>
<h5 id="322-完整停止">3.2.2 完整停止</h5>
<pre><code>cd /usr/local/nginx/sbin
./nginx -s quit
 // 此方式停止步骤是待nginx进程处理任务完毕进行停止。
</code></pre>
<h3 id="33-重启">3.3 重启</h3>
<h5 id="331-先停止再启动">3.3.1 先停止再启动</h5>
<pre><code>// 对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。
如下：
./nginx -s quit
./nginx
</code></pre>
<h5 id="332-重新加载配置文件">3.3.2 重新加载配置文件：</h5>
<pre><code>// 当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下：
./nginx -s reload
</code></pre>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用指令]]></title>
        <id>https://yangyng.github.io/post/zWjpEx39_</id>
        <link href="https://yangyng.github.io/post/zWjpEx39_">
        </link>
        <updated>2019-06-18T09:45:56.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-查看-http-链接情况">1. 查看 HTTP 链接情况</h4>
<pre><code>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
</code></pre>
<h4 id="2-查看当前ip个数和每ip连接数">2. 查看当前IP个数和每IP连接数</h4>
<pre><code>netstat -an | grep 80 | awk '{print $5}' | awk 'BEGIN {FS=&quot;:&quot;} NF==2 {print $1} NF==5 {print $4}' | sort | uniq -c | sort -n
</code></pre>
<h4 id="3-iptables-开放端口">3. iptables 开放端口</h4>
<p>3.1. 关闭firewall：</p>
<blockquote>
<p>systemctl stop firewalld.service</p>
</blockquote>
<p>3.2. 停止firewall</p>
<blockquote>
<p>systemctl disable firewalld.service</p>
</blockquote>
<p>3.3. 安装安装iptables防火墙</p>
<blockquote>
<p>yum install iptables-services</p>
</blockquote>
<p>3.4.升级</p>
<pre><code>yum update iptables 
--允许关联的状态包通过
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
</code></pre>
<p>3.5. 开放特定的端口，以80为例</p>
<blockquote>
<p>iptables -A INPUT -p tcp --dport 80 -j ACCEP</p>
</blockquote>
<p>3.6. 重启</p>
<blockquote>
<p>systemctl restart iptables.service</p>
</blockquote>
<p>3.7. 保存配置</p>
<blockquote>
<p>service iptables save</p>
</blockquote>
<p>3.8. 设置开机自启动</p>
<blockquote>
<p>systemctl enable iptables.service</p>
</blockquote>
<h4 id="4-列出相关目录下的所有目录和文件">4. 列出相关目录下的所有目录和文件</h4>
<blockquote>
<p>ls [选项名] [目录名]</p>
</blockquote>
<pre><code> -a 列出包括.a开头的隐藏文件的所有文件
 -A 通 -a,但是不列出 &quot;.&quot;和&quot;..&quot;
 -l 列出文件的详细信息
 -c 根据ctime 排序显示
 -t 根据文件修改时间排序
 -r  反序排列
 -S 以文件大小排序
 -h  以异度大小显示
 ---color[=WHEN] 用色彩辨别文件类型, WHEN 可以是'never','always'或'auto' 其中之一
   白色:表示普通文件
   蓝色:表示目录
   绿色:表示可执行文件
   红色:表示压缩文件
   浅蓝色:链接文件
   红色闪烁:表示链接的文件有问题
   黄色:表示设备文件
   灰色:表示其他文件
 
</code></pre>
<blockquote>
<blockquote>
<p>例子</p>
</blockquote>
</blockquote>
<pre><code>#  按易读的方式按时间排序,并显示文件详细信息
ls -lhrt
# 按照大小 反序显示文件的详细信息
ls -lrS
# 列出文件绝对路径（不包含隐藏文件）
ls | sed &quot;s:^:`pwd`/:&quot;
# 列出文件绝对路径（包含隐藏文件）
find $pwd -maxdepth 1 | xargs ls -ld
</code></pre>
<h4 id="5-移动或重命名文件">5. 移动或重命名文件</h4>
<blockquote>
<p>mv [选项] 源文件或目录 目录或多个源文件</p>
</blockquote>
<pre><code>-b 覆盖前做备份
-f 如存在不询问而强制覆盖
-i 如存在则询问是否覆盖
-u 较新才覆盖
-t 将多个源文件移动到统一目录下,目录参数在前,文件参数在后
 eg:
  mv a /tmp/ 将文件a 移动到 /tmp 目录下
  mv a b 将a 命令为b
  mv /home/zenghao test1.txt test2.txt test3.txt
</code></pre>
<h4 id="6-将源文件复制至目标文件或将多个源文件复制至目标目录">6. 将源文件复制至目标文件,或将多个源文件复制至目标目录</h4>
<blockquote>
<p>cp [选项] 源文件或目录 目录或多个源文件</p>
</blockquote>
<pre><code>-r -R 递归复制该目录以及子目录内容
-p 连同档案属性一起复制过去
-f 不询问而强制复制
-s 生成快捷方式
-a 将档案的所有特性都一起复制
</code></pre>
<h4 id="7-在linux-服务器之间复制文件和目录">7. 在linux 服务器之间复制文件和目录</h4>
<blockquote>
<p>scp [参数] [原路径] [目标路径]</p>
</blockquote>
<pre><code>-v 详细显示输入的具体情况
-r 递归复制整个目录
(1) 复制文件：  
命令格式：  
scp local_file remote_username@remote_ip:remote_folder  
或者  
scp local_file remote_username@remote_ip:remote_file  
或者  
scp local_file remote_ip:remote_folder  
或者  
scp local_file remote_ip:remote_file  
第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名  
第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名   
(2) 复制目录：  
命令格式：  
scp -r local_folder remote_username@remote_ip:remote_folder  
或者  
scp -r local_folder remote_ip:remote_folder  
第1个指定了用户名，命令执行后需要输入用户密码；  
第2个没有指定用户名，命令执行后需要输入用户名和密码；
eg:
   从 本地 复制到 远程
   scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root 
   从 远程 复制到 本地
   scp root@/172.19.2.75:/home/root/full.tar.gz /home/daisy/full.tar.gz
</code></pre>
<h4 id="8-删除文件">8. 删除文件</h4>
<blockquote>
<p>rm [选项] 文件</p>
</blockquote>
<pre><code>-r 删除文件夹
-f 删除不提示
-i 删除提示
-v 详细显示进行步骤
</code></pre>
<h4 id="9-创建空的文件或更新文件时间">9. 创建空的文件或更新文件时间</h4>
<blockquote>
<p>touch [选项] 文件</p>
</blockquote>
<pre><code>-a 只修改存取时间
-m 只修改变动时间
-r  
  eg:touch -r a b ,使b的时间和a相同
-t 指定特定的时间 
  eg:touch -t 201211142234.50 log.log 
   -t time [[CC]YY]MMDDhhmm[.SS],C:年前两位
</code></pre>
<h4 id="10查看当前所在的路径">10.查看当前所在的路径</h4>
<blockquote>
<p>pwd</p>
<blockquote>
<p>例子</p>
</blockquote>
</blockquote>
<pre><code># 查看软链接的实际路径
pwd -p
</code></pre>
<h4 id="11-改变当前目录">11. 改变当前目录</h4>
<blockquote>
<p>cd</p>
</blockquote>
<pre><code>- ：返回上次目录
.. :返回上层目录
回车  ：返回主目录
/   :根目录
</code></pre>
<h4 id="12-创建新目录">12. 创建新目录</h4>
<blockquote>
<p>mkdir [选项] 目录</p>
</blockquote>
<pre><code>-p 递归创建目录,若父目录不存在则以此创建
-m 自定义创建目录的权限 
  eg: mkdir -m 777 hehe
-v 显示创建目录的详细信息
</code></pre>
<h4 id="13-删除空的目录">13. 删除空的目录</h4>
<blockquote>
<p>rmdir</p>
</blockquote>
<pre><code>-v 显示执行过程
-p 自父目录删除,若父目录为空,则一并删除
</code></pre>
<h4 id="14-删除一个或多个文件或目录">14. 删除一个或多个文件或目录</h4>
<blockquote>
<p>rm [选项] 文件</p>
</blockquote>
<pre><code>-f 忽略不存在的文件,不给出提示
-i 交互式删除
-r 将列出的目录以及子目录递归删除
-v 列出详细的信息
</code></pre>
<h4 id="15-显示内容">15 . 显示内容</h4>
<blockquote>
<p>echo</p>
</blockquote>
<pre><code>-n 输出后不换行
-e 遇到转义字符特殊处理
</code></pre>
<h4 id="16-一次显示整个文件或从键盘创建一个文件或将几个文件合并成一个文件">16. 一次显示整个文件或从键盘创建一个文件或将几个文件合并成一个文件</h4>
<blockquote>
<p>cat [选项 文件</p>
</blockquote>
<pre><code>-n 编号文件内容再输出
-E 在结束行提示$
cat &gt;  fileanme   #创建一个文件
cat file1 file2 &gt; file  # 将几个文件合并为一个文件
</code></pre>
<h4 id="17-反向显示">17. 反向显示</h4>
<blockquote>
<p>tac</p>
</blockquote>
<h4 id="18-按页查看文章内容从前向后读取文件因此在启动的时候就加载整个文件">18. 按页查看文章内容,从前向后读取文件,因此在启动的时候就加载整个文件</h4>
<blockquote>
<p>more</p>
</blockquote>
<pre><code>+n 从第n行开始显示
-n 每次查看n行数据
+/string  搜寻string字符串位置,从其前两行开始查看
-c 清屏再显示
-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能
-l        忽略Ctrl+l（换页）字符
-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似
-s       把连续的多个空行显示为一行
-u       把文件内容中的下画线去掉
</code></pre>
<blockquote>
<p>常用操作命令</p>
</blockquote>
<pre><code>Enter    向下 n 行，需要定义。默认为 1 行
Ctrl+F   向下滚动一屏
空格键  向下滚动一屏
Ctrl+B  返回上一屏
=       输出当前行的行号
:f     输出文件名和当前行的行号
V      调用vi编辑器
!命令   调用Shell，并执行命令
q       退出more
</code></pre>
<h4 id="19-可前后移动的逐屏查看文章内容在查看钱不会加载整个文件">19. 可前后移动的逐屏查看文章内容,在查看钱不会加载整个文件</h4>
<blockquote>
<p>less</p>
</blockquote>
<pre><code>-m 显示类似于more命令的百分比
-N 显示行号
/  字符串:向下搜索&quot;字符串&quot;的功能
?  字符串:向上搜索&quot;字符串&quot;的功能
n  重复前一个搜索(与/或?有关)
b  向后翻一页
d  向后翻半夜
</code></pre>
<blockquote>
<p>常用命令</p>
</blockquote>
<pre><code>-i  忽略搜索时的大小写
-N  显示每行的行号
-o  &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来
-s  显示连续空行为一行
/字符串：向下搜索“字符串”的功能
?字符串：向上搜索“字符串”的功能
n：重复前一个搜索（与 / 或 ? 有关）
N：反向重复前一个搜索（与 / 或 ? 有关）
-x &lt;数字&gt; 将“tab”键显示为规定的数字空格
b  向后翻一页
d  向后翻半页
h  显示帮助界面
Q  退出less 命令
u  向前滚动半页
y  向前滚动一行
空格键 滚动一行
回车键 滚动一页
[pagedown]： 向下翻动一页
[pageup]：   向上翻动一页
</code></pre>
<h4 id="20-将输出内容自动加上行号">20. 将输出内容自动加上行号</h4>
<blockquote>
<p>nl [选项] ...[文件]...</p>
</blockquote>
<pre><code>-b 
-b a 不论是否有空格,都列出行号 (类似 cat -n)
-b t 空格则不列行号(默认)
-n 有ln,rn,rz 三个参数,分别为在最左方显示,最右方显示不加0,最右方显示加0
</code></pre>
<h4 id="21-显示档案开头默认显示10行">21. 显示档案开头,默认显示10行</h4>
<blockquote>
<p>head [参数]...[文件]...</p>
</blockquote>
<pre><code>-v  显示文件名
-c number 显示前number个字符,若number 为负数,则显示除最后number个字符的所有内容
-number/n (+)number 显示前number 行内容
-n number 若number为负数,则显示除最后number行数据的所有内容
</code></pre>
<h4 id="22-显示文件结尾内容">22. 显示文件结尾内容</h4>
<blockquote>
<p>tail [必要参数] [选择参数]</p>
</blockquote>
<pre><code>-v 显示详细的处理信息
-q  不显示处理信息
-num/-n  (-)num  显示最后num 行内容
-c  显示最后c个字符
-f  循环读取
</code></pre>
<h4 id="23-编辑文件">23. 编辑文件</h4>
<blockquote>
<p>vi</p>
</blockquote>
<pre><code>:w filename 将文章以指定的文件名保存起来  
:wq 保存并退出
:q! 不保存而强制退出
:set number 或者 :set nu 显示行号
:set  nonumber 或者 :set nonu 隐藏行号
命令行模式功能键
1）插入模式
   按「i」切换进入插入模式「insert mode」，按&quot;i&quot;进入插入模式后是从光标当前位置开始输入文件；
   按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；
   按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。

2）从插入模式切换为命令行模式
 按「ESC」键。
3）移动光标
　　vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。
　　按「ctrl」+「b」：屏幕往&quot;后&quot;移动一页。
　　按「ctrl」+「f」：屏幕往&quot;前&quot;移动一页。
　　按「ctrl」+「u」：屏幕往&quot;后&quot;移动半页。
　　按「ctrl」+「d」：屏幕往&quot;前&quot;移动半页。
　　按数字「0」：移到文章的开头。
　　按「G」：移动到文章的最后。
　　按「$」：移动到光标所在行的&quot;行尾&quot;。
　　按「^」：移动到光标所在行的&quot;行首&quot;
　　按「w」：光标跳到下个字的开头
　　按「e」：光标跳到下个字的字尾
　　按「b」：光标回到上个字的开头
　　按「#l」：光标移到该行的第#个位置，如：5l,56l。

4）删除文字
　　「x」：每按一次，删除光标所在位置的&quot;后面&quot;一个字符。
　　「#x」：例如，「6x」表示删除光标所在位置的&quot;后面&quot;6个字符。
　　「X」：大写的X，每按一次，删除光标所在位置的&quot;前面&quot;一个字符。
　　「#X」：例如，「20X」表示删除光标所在位置的&quot;前面&quot;20个字符。
　　「dd」：删除光标所在行。
　　「#dd」：从光标所在行开始删除#行

5）复制
　　「yw」：将光标所在之处到字尾的字符复制到缓冲区中。
　　「#yw」：复制#个字到缓冲区
　　「yy」：复制光标所在行到缓冲区。
　　「#yy」：例如，「6yy」表示拷贝从光标所在的该行&quot;往下数&quot;6行文字。
　　「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与&quot;y&quot;有关的复制命令都必须与&quot;p&quot;配合才能完成复制与粘贴功能。

6）替换
　　「r」：替换光标所在处的字符。
　　「R」：替换光标所到之处的字符，直到按下「ESC」键为止。

7）回复上一次操作
　　「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次&quot;u&quot;可以执行多次回复。

8）更改
　　「cw」：更改光标所在处的字到字尾处
　　「c#w」：例如，「c3w」表示更改3个字

9）跳至指定的行
　　「ctrl」+「g」列出光标所在行的行号。
　　「#G」：例如，「15G」，表示移动光标至文章的第15行行首。
</code></pre>
<h4 id="24-查看可执行文件的位置在path变量指定的路径中查看系统命令是否存在及其位置">24. 查看可执行文件的位置,在PATH变量指定的路径中查看系统命令是否存在及其位置</h4>
<blockquote>
<p>which</p>
</blockquote>
<h4 id="25-定位可执行文件源代码文件帮助文件在文件系统中的位置">25. 定位可执行文件,源代码文件,帮助文件在文件系统中的位置</h4>
<blockquote>
<p>whereis [-bmsu] [BMS 目录名 -f] 文件名</p>
</blockquote>
<pre><code>-b 定位可执行文件
-m 定位帮助文件
-s  定位源代码文件
-u  搜索默认路径下除可执行文件,源代码文件,帮助文件以外的其他文件
-B 指定搜索可执行文件的路径
-M 指定搜索帮助文件文件的路径
-S 指定搜索源文件的路径
</code></pre>
<h4 id="26-通过搜寻数据库快速搜寻档案">26. 通过搜寻数据库快速搜寻档案</h4>
<blockquote>
<p>locate</p>
</blockquote>
<pre><code>-r  使用正则运算式做寻找的条件
</code></pre>
<h4 id="27-在文件树中查找文件并作出相应的处理">27. 在文件树中查找文件,并作出相应的处理</h4>
<blockquote>
<p>find [PATH] [option] [action]</p>
</blockquote>
<pre><code>选项与参数：
1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime 和-amin,-cmin与-mmin，以 -mtime 说明
   -mtime n ：n 为数字，意义为在 n 天之前的『一天之内』被更动过内容的档案；
   -mtime +n ：列出在 n 天之前(不含 n 天本身)被更动过内容的档案档名；
   -mtime -n ：列出在 n 天之内(含 n 天本身)被更动过内容的档案档名。
   -newer file ：file 为一个存在的档案，列出比 file 还要新的档案档名

2. 与使用者或组名有关的参数：
   -uid n ：n 为数字，这个数字是用户的账号 ID，亦即 UID
   -gid n ：n 为数字，这个数字是组名的 ID，亦即 GID
   -user name ：name 为使用者账号名称！例如 dmtsai
   -group name：name 为组名，例如 users ；
   -nouser ：寻找档案的拥有者不存在 /etc/passwd 的人！
   -nogroup ：寻找档案的拥有群组不存在于 /etc/group 的档案！

3. 与档案权限及名称有关的参数：
   -name filename：搜寻文件名为 filename 的档案（可使用通配符）
   -size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的档案。这个 SIZE 的规格有：
       c: 代表 byte
       k: 代表 1024bytes。所以，要找比 50KB还要大的档案，就是『 -size +50k 』
   -type TYPE ：搜寻档案的类型为 TYPE 的，类型主要有：
       一般正规档案 (f)
       装置档案 (b, c)
       目录 (d)
       连结档 (l)
       socket (s)
       FIFO (p)
   -perm mode ：搜寻档案权限『刚好等于』 mode的档案，这个mode为类似chmod的属性值，举例来说，-rwsr-xr-x 的属性为4755！
   -perm -mode ：搜寻档案权限『必须要全部囊括 mode 的权限』的档案，举例来说，
       我们要搜寻-rwxr--r-- 亦即 0744 的档案，使用-perm -0744，当一个档案的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来，因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。
   -perm +mode ：搜寻档案权限『包含任一 mode 的权限』的档案，举例来
       说，我们搜寻-rwxr-xr-x ，亦即 -perm +755 时，但一个文件属性为 -rw-------也会被列出来，因为他有 -rw.... 的属性存在！
4. 额外可进行的动作：
   -exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。
   -print ：将结果打印到屏幕上，这个动作是预设动作！
   eg:
       find / -perm +7000 -exec ls -l {} ; ,额外指令以-exec开头，以;结尾{}代替前面找到的内容
   | xargs 
       -i  默认的前面输出用{}代替 
       eg:
           find . -name &quot;*.log&quot; | xargs -i mv {} test4
</code></pre>
<h4 id="28用正则表达式搜索文本并把匹配的行打印出来">28.用正则表达式搜索文本,并把匹配的行打印出来</h4>
<blockquote>
<p>grep &quot;正则表达式&quot; 文件名</p>
</blockquote>
<pre><code>-c  只输出匹配行的计数
-I 不区分大小写
-l 只显示文件名
-v 显示不包含匹配文本的所有行
-n 显示匹配数据以及行数
</code></pre>
<h4 id="29判断文件类型">29.判断文件类型</h4>
<blockquote>
<p>file</p>
</blockquote>
<h4 id="30-压缩解压缩">30. 压缩,解压缩</h4>
<blockquote>
<p>gzip [选项] 文件/文件夹</p>
</blockquote>
<pre><code>-a：使用ASCII文字模式；
-d：解开压缩文件；
-f：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
-h：在线帮助；
-l：列出压缩文件的相关信息；
-L：显示版本与版权信息；
-n：压缩文件时，不保存原来的文件名称及时间戳记；
-N：压缩文件时，保存原来的文件名称及时间戳记；
-q：不显示警告信息；
-r：递归处理，将指定目录下的所有文件及子目录一并处理；
-S或&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;：更改压缩字尾字符串；
-t：测试压缩文件是否正确无误；
-v：显示指令执行过程；
-V：显示版本信息；
-&lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；
--best：此参数的效果和指定“-9”参数相同；
--fast：此参数的效果和指定“-1”参数相同
</code></pre>
<h4 id="31-多个目录或文件打包压缩成一个大文件">31. 多个目录或文件打包,压缩成一个大文件</h4>
<blockquote>
<p>tar [主选项+辅选项] 文件或目录</p>
</blockquote>
<pre><code>主选项：
   -c  建立打包档案，可搭配 -v 来察看过程中被打包的档名(filename)
   -t  察看打包档案的内容含有哪些档名，重点在察看『档名』就是了；
   -x  解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开
辅选项：
   -j  透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 *.tar.bz2
   -z  透过 gzip 的支持进行压缩/解压缩：此时档名最好为 *.tar.gz
   -v  在压缩/解压缩的过程中，将正在处理的文件名显示出来！
   -f filename -f 后面要立刻接要被处理的档名！
   -C 目录   这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
   --exclude FILE：在压缩打包过程中忽略某文件 eg: tar --exclude /home/zenghao -zcvf myfile.tar.gz /home/* /etc
   -p  保留备份数据的原本权限与属性，常用于备份(-c)重要的配置文件
   -P(大写）  保留绝对路径，亦即允许备份数据中含有根目录存在之意；
eg:
   压 缩：tar -jcvf filename.tar.bz2 要被压缩的档案或目录名称
   查 询：tar -jtvf filename.tar.bz2
   解压缩：tar -jxvf filename.tar.bz2 -C 欲解压缩的目录
</code></pre>
<h4 id="32-关机">32. 关机</h4>
<blockquote>
<p>shutdown -n now</p>
</blockquote>
<h4 id="33-显示当前登录的用户">33. 显示当前登录的用户</h4>
<blockquote>
<p>users</p>
</blockquote>
<h4 id="34-登录在本机的用户与来源">34. 登录在本机的用户与来源</h4>
<blockquote>
<p>who</p>
</blockquote>
<pre><code>-H 或 --heading  显示和栏位的标题信息列
</code></pre>
<h4 id="35给当前联机的用户发消息">35.给当前联机的用户发消息</h4>
<blockquote>
<p>wirite</p>
</blockquote>
<h4 id="36-查看用户的登陆日志">36. 查看用户的登陆日志</h4>
<blockquote>
<p>last</p>
</blockquote>
<h4 id="37-查看每个用户的最后登录时间">37. 查看每个用户的最后登录时间</h4>
<blockquote>
<p>lastlog</p>
</blockquote>
<h4 id="38查看用户信息">38.查看用户信息</h4>
<blockquote>
<p>finger [选项][使用者] [用户@主机]</p>
</blockquote>
<pre><code>-a 显示用户的注册名,实际姓名,终端名称,写状态,停滞时间,登录时间等信息
-l 除了用-s 选项显示的信息外,还显示用户主目录,登录shell,邮件状态等信息,以及用户主目录下的.plan,.project和.forward 文件的内容
-p 除了不显示.plan文件和.project 文件之外,与-l 选项相同
</code></pre>
<h4 id="39-查看主机名">39. 查看主机名</h4>
<blockquote>
<p>hostname</p>
</blockquote>
<h4 id="40-别名">40. 别名</h4>
<blockquote>
<p>alias ii = “ls -l” 添加别名</p>
</blockquote>
<blockquote>
<p>unalias ii 清除别名</p>
</blockquote>
<h4 id="41-新增用户">41. 新增用户</h4>
<blockquote>
<p>.useradd [-u UID] [-g 初始群组] [-G 次要群组] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 使用者账号名</p>
</blockquote>
<pre><code>-M 不建立用户目录,
-m  建立用户目录
-r 建立一个系统的账号,这个账号的UID会有限制
-e 账号失效日期,格式为[YYYY-MM=DD]
-D  查看useradd 的各项默认值
</code></pre>
<h4 id="42-密码">42. 密码</h4>
<blockquote>
<p>passwd</p>
</blockquote>
<pre><code>-l  密码失效
-u  与-l 相对,用户解锁
-S 列出登录用户passwd文件的相关参数
-n  后面接天数，shadow 的第 4 字段，多久不可修改密码天数
-x  后面接天数，shadow 的第 5 字段，多久内必须要更动密码
-w  后面接天数，shadow 的第 6 字段，密码过期前的警告天数
-i  后面接『日期』，shadow 的第 7 字段，密码失效日期
使用管道刘设置密码：echo &quot;zeng&quot; | passwd --stdin zenghao
</code></pre>
<h4 id="43-删除用户">43. 删除用户</h4>
<blockquote>
<p>userde</p>
</blockquote>
<pre><code>-r 用户文件一并删除
</code></pre>
<h4 id="44-修改用户密码的相关属性">44. 修改用户密码的相关属性</h4>
<blockquote>
<p>chage [-ldEImMW] 账号名</p>
</blockquote>
<pre><code>-l  列出该账号的详细密码参数；
-d  后面接日期，修改 shadow 第三字段(最近一次更改密码的日期)，格式YYYY-MM-DD
-E  后面接日期，修改 shadow 第八字段(账号失效日)，格式 YYYY-MM-DD
-I  后面接天数，修改 shadow 第七字段(密码失效日期)
-m  后面接天数，修改 shadow 第四字段(密码最短保留天数)
-M  后面接天数，修改 shadow 第五字段(密码多久需要进行变更)
-W  后面接天数，修改 shadow 第六字段(密码过期前警告日期)
</code></pre>
<h4 id="45-修改用户的相关属性">45. 修改用户的相关属性</h4>
<blockquote>
<p>usermod [-cdegGlsuLU] username</p>
</blockquote>
<pre><code>-c  后面接账号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些账号的说明。
-d  后面接账号的家目录，即修改 /etc/passwd 的第六栏；
-e  后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据啦！
-f  后面接天数为 shadow 的第七字段。
-g  后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是GID的字段！
-G  后面接次要群组，修改这个使用者能够支持的群组
-l  后面接账号名称。亦即是修改账号名称， /etc/passwd 的第一栏！
-s  后面接 Shell 的实际档案，例如 /bin/bash 或 /bin/csh 等等。
-u  后面接 UID 数字啦！即 /etc/passwd 第三栏的资料；
-L  冻结密码
-U  解冻密码
</code></pre>
<h4 id="46-查看用户相关的id信息还可以用来判断用户是否存在">46. 查看用户相关的id信息，还可以用来判断用户是否存在</h4>
<blockquote>
<p>id [username]</p>
</blockquote>
<h4 id="47-查看登陆用户支持的群组-第一个输出的群组为有效群组">47. 查看登陆用户支持的群组， 第一个输出的群组为有效群组</h4>
<blockquote>
<p>groups</p>
</blockquote>
<h4 id="48-切换有效群组">48. 切换有效群组</h4>
<blockquote>
<p>newgrp</p>
</blockquote>
<h4 id="49-添加组">49. 添加组</h4>
<blockquote>
<p>groupadd [-g gid] 组名</p>
</blockquote>
<pre><code>-g 设定添加组的特定组的id
</code></pre>
<h4 id="50-修改组信息">50. 修改组信息</h4>
<blockquote>
<p>groupmod [-g gid] [-n group_name] 群组名</p>
</blockquote>
<pre><code>-g  修改既有的 GID 数字
-n  修改既有的组名
</code></pre>
<h4 id="51-删除群组">51. 删除群组</h4>
<blockquote>
<p>groupdel [groupname]</p>
</blockquote>
<h4 id="52群组管理员">52.群组管理员</h4>
<blockquote>
<p>gpasswd</p>
</blockquote>
<pre><code>root管理员动作：
   -gpasswd groupname 设定密码
   -gpasswd [-A user1,...] [-M user3,...] groupname
       -A  将 groupname 的主控权交由后面的使用者管理(该群组的管理员)
       -M  将某些账号加入这个群组当中
   -gpasswd [-r] groupname
       -r  将 groupname 的密码移除
群组管理员动作：
   - gpasswd [-ad] user groupname 
       -a  将某位使用者加入到 groupname 这个群组当中
       -d  将某位使用者移除出 groupname 这个群组当中
</code></pre>
<h4 id="53-修改个人信息">53. 修改个人信息</h4>
<blockquote>
<p>chfn</p>
</blockquote>
<h4 id="54分割">54.分割</h4>
<blockquote>
<p>cut</p>
</blockquote>
<pre><code>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。
-c ：以字符为单位进行分割。
-d ：自定义分隔符，默认为制表符。
-f  ：与-d一起使用，指定显示哪个区域。
</code></pre>
<h4 id="55排序">55.排序</h4>
<blockquote>
<p>sort</p>
</blockquote>
<pre><code>-n   依照数值的大小排序。
-o&lt;输出文件&gt;   将排序后的结果存入指定的文件。
-r   以相反的顺序来排序。
-t&lt;分隔字符&gt;   指定排序时所用的栏位分隔字符。
-k  选择以哪个区间进行排序。
</code></pre>
<h4 id="56-统计指定文件中的字节数-字数-行数-并将统计结果显示输出">56. 统计指定文件中的字节数、字数、行数, 并将统计结果显示输出</h4>
<blockquote>
<p>wc</p>
</blockquote>
<pre><code>-l filename 报告行数
-c filename 报告字节数
-m filename 报告字符数
-w filename 报告单词数
</code></pre>
<h4 id="57-去除文件中相邻的重复行">57. 去除文件中相邻的重复行</h4>
<blockquote>
<p>uniq</p>
</blockquote>
<pre><code>-c或——count：在每列旁边显示该行重复出现的次数；
-d或--repeated：仅显示重复出现的行列；
-f&lt;栏位&gt;或--skip-fields=&lt;栏位&gt;：忽略比较指定的栏位；
-s&lt;字符位置&gt;或--skip-chars=&lt;字符位置&gt;：忽略比较指定的字符；
-u或——unique：仅显示出一次的行列；
-w&lt;字符位置&gt;或--check-chars=&lt;字符位置&gt;：指定要比较的字符。
</code></pre>
<h4 id="58-显示指定磁盘文件的可用空间如果没有文件名被指定则所有当前被挂载的文件系统的可用空间将被显示">58. 显示指定磁盘文件的可用空间,如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示</h4>
<p>功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。 链接分类：软件链接及硬链接 软链接</p>
<p>硬链接</p>
<ul>
<li>硬链接，以文件副本的形式存在。但不占用实际空间。</li>
<li>不允许给目录创建硬链接</li>
<li>硬链接只有在同一个文件系统中才能创建</li>
</ul>
<p>软链接</p>
<ul>
<li>软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li>
<li>软链接可以 跨文件系统 ，硬链接不可以</li>
<li>软链接可以对一个不存在的文件名进行链接</li>
<li>软链接可以对目录进行链接</li>
</ul>
<blockquote>
<p>du</p>
</blockquote>
<pre><code>-a  显示全部文件系统
-h  文件大小友好显示
-l  只显示本地文件系统
-i  显示inode信息
-T  显示文件系统类型
</code></pre>
<blockquote>
<blockquote>
<p>例子</p>
</blockquote>
</blockquote>
<pre><code>#  给文件创建软链接,并显示操作信息
ln -sv source.log link.log
#  给文件创建硬链接,并显示操作信息
ln -v source.log link1.log
#  给目录创建软链接
ln -sv /opt/soft/test/test3 /opt/soft/test/test5
</code></pre>
<h4 id="59显示每个文件和目录的磁盘使用空间">59.显示每个文件和目录的磁盘使用空间</h4>
<blockquote>
<p>du [选项][文件]</p>
</blockquote>
<pre><code>-h 方便阅读的方式
-s 只显示总和的大小
</code></pre>
<h4 id="60-某一个文件在另外一个位置建立一个同步的链接">60. 某一个文件在另外一个位置建立一个同步的链接</h4>
<blockquote>
<p>ln [参数] [源文件或目录] [目标文件或目录]</p>
</blockquote>
<pre><code>-s  建立软连接   
-v  显示详细的处理过程
</code></pre>
<h4 id="61-比较单个文件或者目录内容">61. 比较单个文件或者目录内容</h4>
<blockquote>
<p>diff [参数] [文件1或目录1] [文件2或目录2]</p>
</blockquote>
<pre><code>-b 　不检查空格字符的不同。
-B 　不检查空白行。
-i  不检查大小写
-q  仅显示差异而不显示详细信息
eg: diff a b &gt; parch.log 比较两个文件的不同并产生补丁
</code></pre>
<h4 id="62-显示或设定系统的日期与时间">62. 显示或设定系统的日期与时间</h4>
<blockquote>
<p>date [参数]… [+格式]</p>
</blockquote>
<pre><code>%H 小时(以00-23来表示)。 
%M 分钟(以00-59来表示)。 
%P AM或PM。
%D 日期(含年月日)
%U 该年中的周数。
date -s “2015-10-17 01:01:01″ //时间设定
date +%Y%m%d         //显示前天年月日
date +%Y%m%d --date=&quot;+1 day/month/year&quot;  //显示前一天/月/年的日期
date +%Y%m%d --date=&quot;-1 day/month/year&quot;  //显示后一天/月/年的日期
date -d '2 weeks' 2周后的日期
</code></pre>
<h4 id="63-查看日历">63. 查看日历</h4>
<blockquote>
<p>cal [参数] 月份] [年份]</p>
</blockquote>
<pre><code>-1  显示当月的月历
-3  显示前、当、后一个月的日历
-m  显示星期一为一个星期的第一天
-s  （默认）星期天为第一天
-j  显示当月是一年中的第几天的日历
-y  显示当前年份的日历
</code></pre>
<h4 id="64-列出当前进程的快照">64. 列出当前进程的快照</h4>
<blockquote>
<p>ps</p>
</blockquote>
<pre><code>a   显示所有的进程
-a  显示同一终端下的所有程序
e   显示环境变量
f   显示进程间的关系
-H  显示树状结构
r   显示当前终端的程序
T   显示当前终端的所有程序
-au 显示更详细的信息
-aux    显示所有包含其他使用者的行程 
-u  指定用户的所有进程
</code></pre>
<h4 id="65-显示当前系统正在执行的进程的相关信息包括进程id-内存占用率-cpu占用率等">65. 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</h4>
<blockquote>
<p>top</p>
</blockquote>
<h4 id="66-杀死进程">66. 杀死进程</h4>
<blockquote>
<p>kill [参数] [进程号]</p>
</blockquote>
<h4 id="67-显示linux系统中空闲的-已用的物理内存及swap内存及被内核使用的buffer">67. 显示linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer</h4>
<blockquote>
<p>free [参数]</p>
</blockquote>
<h4 id="68-对操作系统的虚拟内存-进程-cpu活动进行监控">68. 对操作系统的虚拟内存、进程、CPU活动进行监控</h4>
<blockquote>
<p>vmstat</p>
</blockquote>
<h4 id="69-对系统的磁盘操作活动进行监视汇报磁盘活动统计情况同时也会汇报出cpu使用情况">69. 对系统的磁盘操作活动进行监视,汇报磁盘活动统计情况，同时也会汇报出CPU使用情况</h4>
<blockquote>
<p>iostat [参数] [时间t] [次数n](每隔t时间刷新一次，最多刷新n次）</p>
</blockquote>
<pre><code>-p[磁盘] 显示磁盘和分区的情况
</code></pre>
<h4 id="70-重复执行某一命令以观察变化">70. 重复执行某一命令以观察变化</h4>
<blockquote>
<p>watch [参数] [命令]</p>
</blockquote>
<pre><code>-n  时隔多少秒刷新
-d  高亮显示动态变化
</code></pre>
<h4 id="71-在一个指定的时间执行一个指定任务只能执行一次">71. 在一个指定的时间执行一个指定任务，只能执行一次</h4>
<blockquote>
<p>at [参数] [时间]</p>
</blockquote>
<pre><code>HH:MM[am|pm] + number [minutes|hours|days|weeks] 强制在某年某月某日的某时刻进行该项任务
atq 查看系统未执行的任务
atrm n 删除编号为n的任务
at -c n 显示编号为n的任务的内容
</code></pre>
<h4 id="72-定时任务调度">72. 定时任务调度</h4>
<blockquote>
<p>crontab</p>
</blockquote>
<pre><code>file    载入crontab
-e  编辑某个用户的crontab文件内容
-l  显示某个用户的crontab文件内容
-r  删除某个用户的crontab文件
</code></pre>
<h4 id="73-查看和配置网络设备">73. 查看和配置网络设备</h4>
<blockquote>
<p>ifconfig [网络设备] [参数]</p>
</blockquote>
<h4 id="74-显示和操作ip路由表">74. 显示和操作IP路由表</h4>
<blockquote>
<p>route</p>
</blockquote>
<h4 id="75-测试与目标主机的连通性">75. 测试与目标主机的连通性</h4>
<blockquote>
<p>ping [参数] [主机名或IP地址]</p>
</blockquote>
<pre><code>-q  只显示最后的结果
</code></pre>
<h4 id="76-显示与ip-tcp-udp和icmp协议相关的统计数据">76. 显示与IP、TCP、UDP和ICMP协议相关的统计数据</h4>
<blockquote>
<p>netstat</p>
</blockquote>
<h4 id="77-用于远程登录采用明文传送报文安全性不好">77. 用于远程登录，采用明文传送报文，安全性不好</h4>
<blockquote>
<p>telnet [参数] [主机]</p>
</blockquote>
<h4 id="78-远程文件拷贝">78. 远程文件拷贝</h4>
<blockquote>
<p>rcp [参数] [源文件] [目标文件]</p>
</blockquote>
<pre><code>-r  递归复制
-p  保留源文件的属性
usage: rcp –r remote_hostname:remote_dir local_dir
</code></pre>
<h4 id="79-直接从网络上下载文件">79. 直接从网络上下载文件</h4>
<blockquote>
<p>wget [参数] [URL地址]</p>
</blockquote>
<pre><code>-o FILE 把记录写到FILE文件中    eg : wget -O a.txt URL
wget --limit-rate=300k URL  限速下载
</code></pre>
<h4 id="80-对数据行进行替换-删除-新增-选取等操作">80. 对数据行进行替换、删除、新增、选取等操作</h4>
<blockquote>
<p>sed</p>
</blockquote>
<pre><code>a   新增，在新的下一行出现
c   取代，取代 n1,n2 之间的行 eg: sed '1,2c Hi' ab
d   删除
i   插入，在新的上一行出现
</code></pre>
<h4 id="81-合并文件需确保合并的两文件行数相同">81. 合并文件，需确保合并的两文件行数相同</h4>
<blockquote>
<p>paste</p>
</blockquote>
<pre><code>-d  指定不同于空格或tab键的域分隔符
-s  按行合并，单独一个文件为一行
</code></pre>
<h4 id="82-授予用户文件夹权">82 授予用户文件夹权</h4>
<blockquote>
<p>chown</p>
</blockquote>
<pre><code> chown -R 用户名   文件夹
</code></pre>
<h4 id="83-df-命令">83 df 命令</h4>
<p>显示磁盘空间的使用情况</p>
<pre><code>-a 全部文件系统列表
-h 以方便阅读的方式显示信息
-i 显示inode信息
-k 区块为1024字节
-l 只显示本地磁盘
-T 列出文件系统类型
</code></pre>
<h4 id="84-用命令行运行deb安装包">84. 用命令行运行deb安装包</h4>
<pre><code>如果ubuntu要安装新软件，已有deb安装包（例如：iptux.deb），但是无法登录到桌面环境。那该怎么安装？答案是：使用dpkg命令。
dpkg命令常用格式如下：
sudo dpkg -I iptux.deb #查看iptux.deb软件包的详细信息，包括软件名称、版本以及大小等（其中-I等价于--info）
sudo dpkg -c iptux.deb #查看iptux.deb软件包中包含的文件结构（其中-c等价于--contents）
sudo dpkg -i iptux.deb #安装iptux.deb软件包（其中-i等价于--install）
sudo dpkg -l iptux #查看iptux软件包的信息（软件名称可通过dpkg -I命令查看，其中-l等价于--list）
sudo dpkg -L iptux #查看iptux软件包安装的所有文件（软件名称可通过dpkg -I命令查看，其中-L等价于--listfiles）
sudo dpkg -s iptux #查看iptux软件包的详细信息（软件名称可通过dpkg -I命令查看，其中-s等价于--status）
sudo dpkg -r iptux #卸载iptux软件包（软件名称可通过dpkg -I命令查看，其中-r等价于--remove）
注：dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。
</code></pre>
<h5 id="85-ubuntu-1804修改默认源为国内源">85. Ubuntu 18.04修改默认源为国内源</h5>
<pre><code>修改阿里源为Ubuntu 18.04默认的源

备份/etc/apt/sources.list
#备份
cp /etc/apt/sources.list /etc/apt/sources.list.bak

在/etc/apt/sources.list文件前面添加如下条目
#添加阿里源
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse

最后执行如下命令更新源
##更新
sudo apt-get update
sudo apt-get upgrade

另外其他几个国内源如下： 
中科大源
##中科大源
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse

163源
##163源
deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse

清华源
##清华源
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
</code></pre>
<h5 id="86-修改用户为sudo-免密码">86 修改用户为sudo 免密码</h5>
<pre><code>1. 编辑 sudo vi /etc/sudoers
2. 找到 root　　ALL=(ALL:ALL) ALL，在下边添加类似的一行
linuxidc　　ALL=(ALL:ALL) ALL
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[什么是HashMap?]]></title>
        <id>https://yangyng.github.io/post/RZblMP02A</id>
        <link href="https://yangyng.github.io/post/RZblMP02A">
        </link>
        <updated>2019-06-18T08:05:39.000Z</updated>
        <content type="html"><![CDATA[<h4 id="什么是hashmap">什么是HashMap</h4>
<p>hashMap 是一个用于存储KEY-VALUE键值对的集合,每一个键值对也叫作Entry.这些个键值对(Entry)分散存储在一个数组中.</p>
<p><img src="https://yangyng.github.io/post-images/1560845187679.png" alt=""></p>
<p>HashMap 的初始值大小为 16</p>
<p>HashMap中我们最常用到的两个方法: <strong>GET</strong> <strong>PUT</strong></p>
<h6 id="put方法的原理"><strong>PUT</strong>方法的原理</h6>
<p>首先 调用<strong>PUT</strong>方法时 都发生了什么?</p>
<blockquote>
<ol>
<li>
<p>hash(key)  使用该hash函数来确定呢Entry的插入位置</p>
<p>首先 HashMap的长度是有限的</p>
<p>那么 当插入的Entry越来越多时,使用hash(key)函数计算出来的hash值就必定会存在相同的情况</p>
</li>
<li>
<p>对于相同的hash值 该怎么办? (<strong>hash冲突</strong>) =&gt; <strong>链表</strong></p>
<p>HashMap 数组的每一个元素不止是一个Entry对象,也是一个链表的头节点.每一个Entry对象通过Next指针指向它的下一个Entry节点.当新来的Entry映射到冲突的数组位置时,只需要插入到对应的链表即可.</p>
<p><img src="https://yangyng.github.io/post-images/1560845208688.png" alt=""></p>
<p>**注意: **新来的Entry节点插入链表时,使用的是&quot;头插法&quot;,即最新的元素放在链表的头部. <strong>因为HashMap的发明者认为,后插入的Entry被查找的可能性更大</strong></p>
</li>
</ol>
</blockquote>
<pre><code>//以下部分为 hashMap中的源码
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
}
//putVal 方法
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式锁及其实现方式]]></title>
        <id>https://yangyng.github.io/post/UzPIBHidO</id>
        <link href="https://yangyng.github.io/post/UzPIBHidO">
        </link>
        <updated>2019-06-17T09:21:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="分布式锁及相关">分布式锁及相关</h3>
<blockquote>
<p>分布式锁的概念 =&gt; 是控制分布式系统之间同步访问共享资源的一种方式</p>
<p>使用场景 =&gt; 在分布式系统中,常常需要协调他们的动作,如果不同的系统或是同一个系统能够的不同主机之间共享了一个或 一组资源,那么访问这些资源的时候,往往需要互斥来防止彼此干扰来保证一致性,在这种情况下,便需要使用到分布式锁</p>
<p>保证可用性 =&gt;</p>
<ul>
<li>==互斥性==,在任意时刻,只有一个客户端能够持有该锁</li>
<li>==不会死锁==(死锁 =&gt; 当两个以上的请求方,双方都在等待对方释放锁,以获取系统资源,但没有一方提前退出时,就成为死锁 ==两个人过独木桥==)</li>
<li>==容错性== 有一个客户端在持有锁的期间崩溃而没有主动解锁,也能保证后续其它客户端能使用该锁</li>
</ul>
</blockquote>
<h4 id="基于redis的分布式锁">基于REDIS的分布式锁</h4>
<h5 id="redission-简介">Redission 简介</h5>
<blockquote>
<p>Redis客户端在基于NIO的Netty框架上,充分的利用了Redis键值数据库提供的一系列优势,在Java实现工具包中常用接口的基础上,未使用这提供了一系列具有分布式特性的常用工具类</p>
<p>支持Redis 单实例 哨兵 Cluster master-slave 等各种部署架构</p>
</blockquote>
<h6 id="1-redis使用lua脚本的-好处">1. redis使用lua脚本的 好处</h6>
<ol>
<li>原子性 Lua脚本是做为一个整体执行的,所以中间不会被其它命令插入</li>
<li>减少网络开销 可以把多条命令一次性打包</li>
</ol>
<h6 id="2-基本思路">2. 基本思路</h6>
<ol>
<li>锁ID作为redis的key value为hash结构 hash的filed为获得锁的客户端ID value为加锁次数</li>
<li>成功新建写入锁的Key对应的Hash的客户端占用锁</li>
<li>==代码待补充==</li>
<li>客户端不断循环重试执行Lua脚本,知道获得锁</li>
<li>锁互斥机制 Lua脚本保证并发情况下加锁的原子性,中间不会被其他命令插入</li>
</ol>
<h6 id="3-可重入锁机制">3. 可重入锁机制</h6>
<blockquote>
<p>如果以获取客户端线程再次获取锁,该客户端线程的锁的次数+1</p>
</blockquote>
<h6 id="4-释放锁机制">4. 释放锁机制</h6>
<p>该客户端的锁的次数-1
如果发现加锁次数是0了,说明这个客户端已经不在持有锁了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql Linux 环境下 使用Docker安装]]></title>
        <id>https://yangyng.github.io/post/YFjckJCA7</id>
        <link href="https://yangyng.github.io/post/YFjckJCA7">
        </link>
        <updated>2019-06-17T09:14:31.000Z</updated>
        <content type="html"><![CDATA[<h5 id="mysql-linux-环境下-使用docker安装">Mysql Linux 环境下 使用Docker安装</h5>
<blockquote>
<pre><code>docker search mysql 用于查询所有可用的mysql镜像
</code></pre>
</blockquote>
<blockquote>
<pre><code>docker images -a 查看下载的镜像
</code></pre>
</blockquote>
<blockquote>
<pre><code>docker ps 查看运行中的 docker 进程
</code></pre>
</blockquote>
<blockquote>
<pre><code>docker run -it --rm --name mysql -e MYSQL_ROOT_PASSWORD=[你的密码] -p 3306:3306 -d mysql 启动mysql进程
</code></pre>
</blockquote>
<blockquote>
<pre><code>docker exec -it mysql bash 进入docker命令行模式
mysql -uroot -p[你的密码] 进入mysql 
</code></pre>
</blockquote>
<blockquote>
<pre><code>select host,user,plugin,authentication_string from mysql.user; 查看用户信息
</code></pre>
<p>如果存在以下记录:</p>
<table>
<thead>
<tr>
<th style="text-align:center">host</th>
<th style="text-align:center">user</th>
<th style="text-align:center">plugin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">root</td>
<td style="text-align:center">caching_sha2_password</td>
</tr>
</tbody>
</table>
<p>执行如下SQL</p>
<pre><code>ALTER user 'root'@'%' IDENTIFIED WITH mysql_native_password BY '[你的密码]'; 
</code></pre>
<p>执行之后的结果如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">host</th>
<th style="text-align:center">user</th>
<th style="text-align:center">plugin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">root</td>
<td style="text-align:center">mysql_native_password</td>
</tr>
</tbody>
</table>
<p>然后执行如下SQL更新配置</p>
<pre><code>FLUSH PRIVILEGES;
</code></pre>
<p>即可正常使用</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Redis 常用配置项]]></title>
        <id>https://yangyng.github.io/post/rcmQSI3Yq</id>
        <link href="https://yangyng.github.io/post/rcmQSI3Yq">
        </link>
        <updated>2019-06-17T09:11:37.000Z</updated>
        <content type="html"><![CDATA[<h4 id="redis-常用配置项">Redis 常用配置项</h4>
<h5 id="设置redis以守护进程方式运行">设置redis以守护进程方式运行</h5>
<blockquote>
<p>daemonize no</p>
</blockquote>
<h5 id="指定端口号">指定端口号</h5>
<blockquote>
<p>port 6379</p>
</blockquote>
<h5 id="设置tcp的backlog">设置tcp的backlog</h5>
<blockquote>
<p>tcp-backlog 511</p>
</blockquote>
<p>**注意: **</p>
<pre><code>backlog 是一个连接队列 
backlog队列总和 = 未完成三次握手队列 + 已完成三次握手队列
在高并发环境下需要一个高的backlog值来避免慢客户端连接问题
Linux内核会将这个值减小到/proc/sys/net/core/somaxconn 的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的
</code></pre>
<h5 id="绑定的主机地址">绑定的主机地址</h5>
<blockquote>
<p>bind 127.0.0.1</p>
</blockquote>
<h5 id="客户端闲置时间关闭连接-单位-秒-设置为-0-则永不关闭">客户端闲置时间关闭连接 单位 秒 设置为 0 则永不关闭</h5>
<blockquote>
<p>timeout 300</p>
</blockquote>
<h5 id="检测客户端网络中断时间间隔-单位-秒-设置为-0-则永不检测-建议设置-60">检测客户端网络中断时间间隔 单位 秒 设置为 0 则永不检测 建议设置 60</h5>
<blockquote>
<p>tcp-keepalive 0</p>
</blockquote>
<h5 id="日志级别-debug-verbose-notice-warning-默认值-verbosewindows-安装时-查看为-notice">日志级别 debug verbose notice warning 默认值 verbose(windows 安装时 查看为  notice)</h5>
<blockquote>
<p>loglevel notice</p>
</blockquote>
<h5 id="日志记录方式-默认为标准输出-如果配置-redis-为守护进程方式运行-在这里有配置为日志记录方式为标准输出-则日志将会发送给-devnull">日志记录方式 默认为标准输出 如果配置 redis 为守护进程方式运行, 在这里有配置为日志记录方式为标准输出 则日志将会发送给 /dev/null</h5>
<blockquote>
<p>logfile stdout</p>
</blockquote>
<h5 id="设置数据库数量-默认值-16-默认当前数据库-0-可以使用-select-dbid-指定数据库id">设置数据库数量 默认值 16 默认当前数据库 0 可以使用  select <dbid> 指定数据库id</h5>
<blockquote>
<p>databases 16</p>
</blockquote>
<h5 id="指定在多长时间内-有多少次更新操作-就将数据同步到数据文件-多条件时-同时成立">指定在多长时间内 有多少次更新操作 就将数据同步到数据文件 多条件时 同时成立</h5>
<blockquote>
<p>save <seconds> <changes></p>
</blockquote>
<blockquote>
<p>示例 save 300 10 <strong>300秒内有10个更改就将数据同步到数据文件</strong></p>
</blockquote>
<h5 id="指定存储到数据库时是否压缩-默认-yes-redis-采用-lzf压缩">指定存储到数据库时是否压缩 默认 yes  redis 采用 LZF压缩</h5>
<blockquote>
<p>rdbcompssion yes</p>
</blockquote>
<h5 id="指定本地数据库文件名">指定本地数据库文件名</h5>
<blockquote>
<p>dbfilename dump.rdb</p>
</blockquote>
<h5 id="本地数据库存放地址">本地数据库存放地址</h5>
<blockquote>
<p>dir ./</p>
</blockquote>
<h5 id="设置本机-slave-服务时-设置master服务的ip地址及端口号在redis启动时自动从master进行数据同步">设置本机 slave 服务时 设置master服务的IP地址及端口号,在redis启动时,自动从master进行数据同步</h5>
<blockquote>
<p>slaveof <masterIP> <masterPort></p>
</blockquote>
<h5 id="master服务设置密码保护时-salve服务连接master-密码">master服务设置密码保护时 salve服务连接master 密码</h5>
<blockquote>
<p>masterauth <master-password></p>
</blockquote>
<h5 id="设置redis连接密码-如果配置连接密码-客户端连接时-需要通过-authpassword提供密码-默认关闭">设置redis连接密码 如果配置连接密码 客户端连接时 需要通过 auth<password>提供密码 默认关闭</h5>
<blockquote>
<p>requirepass foobared</p>
</blockquote>
<h5 id="设置同一时间最大客户端连接数">设置同一时间最大客户端连接数</h5>
<blockquote>
<p>maxclients 128</p>
<p>**注意: **</p>
<p>默认无限制</p>
<p>当客户端连接数达到限制时  redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</p>
</blockquote>
<h5 id="指定redis最大的内存限制">指定redis最大的内存限制</h5>
<blockquote>
<p>maxmemory <bytes></p>
<p>**注意: **</p>
<p>redis 启动时会将数据加载到内存中</p>
<p>达到最大内存后,redis在尝试清除已到期或即将到期的KEY,当方法处理后,仍然达到最大内存设置,将无法再进行写入操作,但仍可以进行读取操作</p>
<p>Redis 新的VM机制 会把key存放内存,value存放在 swap区</p>
</blockquote>
<h5 id="缓存过期策略很重要">缓存过期策略&lt;很重要&gt;</h5>
<blockquote>
<ul>
<li>
<p>volatile-lru 使用LRU算法(最近最少使用) 只对设置了过期时间的key</p>
</li>
<li>
<p>volatile-random 随机移除 只对设置了过期时间的key</p>
</li>
<li>
<p>volarile-ttl 移除ttl值最小以即最近要过期的key</p>
</li>
<li>
<p>allkeys-lru 使用LRU算法 针对所有</p>
</li>
<li>
<p>allkeys-random 随机移除 同上</p>
</li>
<li>
<p>noeviction 永不过期 针对写操作 会返回错误信息</p>
<p>maxmemory-policy noeviction</p>
</li>
</ul>
</blockquote>
<h5 id="是否在每次默认操作后进行日志记录">是否在每次默认操作后进行日志记录</h5>
<blockquote>
<p>redis 在默认情况下是一步的将数据写入磁盘,如果不开启 可能会在断电时导致一段时间内数据丢失</p>
<p>因为redis本身同步数据文件是按上面save条件来同步的,所有的数据会在一段时间内置存在内存中</p>
<p>appendonly no</p>
</blockquote>
<h5 id="指定更新日志文件名">指定更新日志文件名</h5>
<blockquote>
<p>appendfilename appendonly.aof</p>
</blockquote>
<h5 id="指定更新日志条件">指定更新日志条件</h5>
<blockquote>
<p>no 等操作系统进行数据缓存到磁盘(快)</p>
<p>always 每次更新操作后手动调用fsync()将数据写到磁盘(慢 安全)</p>
<p>everysec 每秒同步一次(折中  默认值)</p>
<p>appendfsync everysec</p>
</blockquote>
<h5 id="是否启用虚拟内存机制">是否启用虚拟内存机制</h5>
<blockquote>
<p>默认值 no</p>
<p>VM机制是将数据分页存放</p>
<p>redis将访问量较小的页 及冷数据swap到磁盘上,访问多的页面由磁盘自动换出到内存中</p>
<p>vm-enabled no</p>
</blockquote>
<h5 id="虚拟内存路径-不可多个redis实例共享">虚拟内存路径 不可多个redis实例共享</h5>
<blockquote>
<p>wm-swap-file /temp/redis.swap</p>
</blockquote>
<h5 id="将所有大于-vm-max-memory-的数据存入虚拟内存">将所有大于 vm-max-memory 的数据存入虚拟内存</h5>
<blockquote>
<p>无论 vm-max-memory设置的多小,所有索引数据都是内存存储的(redis的索引数据就是keys)</p>
<p>当vm-max-memory设置为0时,其实就是讲所有value都存放在磁盘 默认值为0</p>
<p>vm-max-memory 0</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何使用RabbitMQ的一点小总结]]></title>
        <id>https://yangyng.github.io/post/mS0iMd-bJ</id>
        <link href="https://yangyng.github.io/post/mS0iMd-bJ">
        </link>
        <updated>2019-06-17T08:53:52.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="本文主要介绍一些mq的基础概念以及简单的安装使用">本文主要介绍一些MQ的基础概念,以及简单的安装使用</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="本文主要介绍一些mq的基础概念以及简单的安装使用">本文主要介绍一些MQ的基础概念,以及简单的安装使用</h3>
<!-- more -->
<h2 id="rabbit-mq-windows-安装-注意事项">rabbit mq windows 安装 注意事项</h2>
<h3 id="erlang-安装">erlang 安装</h3>
<p><strong>下载地址</strong></p>
<p><a href="http://www.erlang.org/downloads" title="erlang 下载路径">http://www.erlang.org/downloads</a></p>
<p><strong>环境变量配置</strong> <code>ERLANG_HOME 安装路径</code></p>
<p><strong>注意事项</strong>
安装erlang 时注意 一致</p>
<pre><code>C:\Windows\System32\config\systemprofile\.erlang.cookie

C:\Users\用户名\.erlang.cookie
</code></pre>
<hr>
<h3 id="rabbit-mq-安装">rabbit mq 安装</h3>
<p><strong>下载地址</strong></p>
<p><a href="https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.5" title="rabbit mq下载路径">https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.5</a></p>
<p>出现失败时</p>
<pre><code>rabbit-service start 启动服务
rabbit-service stop 关闭服务
rabbit-service remove 移除服务
rabbitmq-plugins enable rabbitmq_management 安装页面管理工具
</code></pre>
<hr>
<h3 id="rabbit-mq-使用">rabbit mq 使用</h3>
<pre><code>//获取连接
ConnectionFactory connectionFactory = new ConnectionFactory();
//地址
connectionFactory.setHost(&quot;127.0.0.1&quot;);
//端口号
connectionFactory.setPort(5672);
//用户名
connectionFactory.setUserName(&quot;guest&quot;);
//密码
connectionFactory.setPassword(&quot;guest&quot;);
//获取连接
Connection connection = connectionFactory.getConnection();
//获取通道
Channel channel = connection.getChannel();
//test 队列名称
channel.queueDeclare(&quot;test&quot;,false,false,false,null);
//消息
String message = &quot;this is a test message&quot;;
//发送消息
channel.basicPublish(&quot;&quot;,&quot;test&quot;,null,message.getBytes());
//关闭频道 关闭连接
channel.close();
connection.close();
</code></pre>
<hr>
<h3 id="基本知识简介">基本知识简介</h3>
<ol>
<li>ConnectionFactory 用来获取连接</li>
<li>connection rabbitMq的socket连接,丰庄路socket协议相关部分逻辑</li>
<li>channel用来定义Queue(队列)定义Exchange(交换机)绑定Queue与Exchange 发布消息等操作</li>
</ol>
<h3 id="queue">queue</h3>
<p>rabbitMq的内部对象 用来存储消息</p>
<h4 id="message-acknowledgment">Message acknowledgment</h4>
<p>消息确认机制</p>
<pre><code>mq在收到消息回执时将消息从queue中移除,如果没有收到回执,并检测到消费者的rabbitmq连接断开,会将消息发送给其它消费者(如果存在多个消费者)处理
</code></pre>
<p>开发过程注意</p>
<pre><code>处理完业务逻辑后,没有发送回执给RabbitMQ,会导致Queue中的消息越来越多,消费者重启后出现消息的重复消费问题
</code></pre>
<p>消息的持久化以及消息的事务性</p>
<h4 id="prefetch-count">Prefetch count</h4>
<p>可以设置该参数控制发给每个消费者的消息数.<img src="http://ostest.qiniudn.com/wordpress/wp-content/uploads/2014/02/2014-2-21-9-49-08.png" alt="Prefetch count">比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息。</p>
<h4 id="声明queue">声明Queue</h4>
<ul>
<li>
<p>消费者无法订阅或者获取不存在的Queue中的信息</p>
</li>
<li>
<p>消息被Exchange接受之后,如果没有匹配的Queue,会被丢弃</p>
<p>无论是消费者还是生产者,在使用时,即发送或者接受消息是,去尝试建立消息队列,因为加入客户端去尝试创建一个已经存在的消息队列时,是不会做任何操作,并返回成功.</p>
<p>一个消费者在一个信道中正在监听一个队列的消息时,不允许该消费者在同一个channel中声明其它队列</p>
</li>
</ul>
<p>声明方式 queue.declare</p>
<ul>
<li>
<p><strong>Exclusive 排他队列</strong></p>
<p>该队列仅对首次声明它的连接可见,并在连接断开时自动删除.</p>
<p>1.排他队列是基于连接可见的,同一连接的不同信道可以同时访问同一个连接创建的排他队列</p>
<p>2.一个连接已经声明了一个排他队列,其它连接不允许建立同名的排他队列.</p>
<p>3.即使设置该队列是持久化的,一旦连接关闭或者客户端退出,该排他队列都会被自动删除.</p>
</li>
<li>
<p><strong>Auto-delete 自动删除</strong> 适用于临时队列</p>
</li>
<li>
<p><strong>durable持久化</strong> 在连接断开或者客户端重启后仍会存活</p>
</li>
</ul>
<p><strong>总结</strong></p>
<pre><code>存活周期仅限于当前连接
自动删除的特性
仅能创建一次
</code></pre>
<hr>
<h4 id="路由规则">路由规则</h4>
<ul>
<li><strong>direct 路由规则完全相同 <em>exp:</em> ==</strong></li>
<li><strong>topic 模糊匹配路由规则 <em>exp:</em> like</strong></li>
<li><strong>fanout 发布与订阅方式</strong></li>
</ul>
<h4 id="消费者订阅消息">消费者订阅消息</h4>
<ul>
<li>
<p><strong>basic.consume</strong></p>
<p>订阅某队列中的消息后,channel自动在处理完上一条消息后,接受下一条消息.(同一个channel中消息处理是并行的)除非关闭channel或者取消订阅,否则客户端将会一直接收队列的消息.</p>
</li>
<li>
<p><strong>basic.get</strong></p>
<p>主动获取队列中的消息,但是不可以通过循环调用basic.get来代替basic.consume,basic,get在实际执行的时候,首先consume某一队列,然后检索第一条消息,然后在取消订阅,在高吞吐量的消费者,最好使用第一种方式</p>
</li>
</ul>
<p>多个消费者同时订阅同一个队列,RabbitMQ是采用循环的方式分发消息的,每一条消息只能被一个订阅者接收.消费者在接到消息时,需要给服务器发送一套确认命令,可以在HandelDelivery中调用basic.ack实现,也可以在consume某个队列时,设置autoACK属性为true.如果消费者在接到消息以后还没来得及返回ACK就断开了连接,消息服务器会重传该消息给下一个订阅者,没有订阅者就会存储该消息.</p>
<hr>
<h4 id="生产者消息确认">生产者消息确认</h4>
<ol>
<li>
<p>事务机制</p>
<pre><code> Channel channel = getChannel();

 //将信道置为 publisher confirm 模式
 try {
     channel.txSelect();
     channel.basicPublish(&quot;TEST_DIRECT_EXCHANGE&quot;, &quot;TEST_QUEUE&quot;,
             null, &quot;this is a test msg&quot;.getBytes());
     int result = 1 / 0;
     channel.txCommit();
 } catch (IOException e) {
     channel.txRollback();
     channel.close();
 }
</code></pre>
</li>
<li>
<p>发送方确认机制</p>
<p>Channel channel = getChannel();</p>
<pre><code> //将信道置为 publisher confirm 模式
 channel.confirmSelect();

 channel.basicPublish(&quot;TEST_DIRECT_EXCHANGE&quot;, &quot;TEST_QUEUE&quot;,
         null, &quot;this is a test msg&quot;.getBytes());

 if (channel.waitForConfirms()) {
     System.out.println(&quot;msg send failure %n hhh&quot;);
 }

 channel.close();
</code></pre>
</li>
<li>
<p>批量confirm</p>
</li>
<li>
<p>异步confirm</p>
</li>
</ol>
<p><strong>QPS</strong></p>
<p><strong>异步confirm 支持的峰值最高</strong></p>
<p><strong>均值 异步与批量相差不多 大约是其他两种的五到六倍</strong></p>
<p><strong>均值 普通confirm 比事务方式略高</strong></p>
<h4 id="消息的消费">消息的消费</h4>
<p>对于同一个消息队列 如果拥有多个消费者时 队列收到的消息将以轮询的分发方式发送给消费者</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ 使用延迟队列的一点代码]]></title>
        <id>https://yangyng.github.io/post/8doV_ak0A</id>
        <link href="https://yangyng.github.io/post/8doV_ak0A">
        </link>
        <updated>2019-06-17T08:51:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="关于rabbitmq发送延迟队列的实现">关于RabbitMQ发送延迟队列的实现</h4>
<blockquote>
<p>生产者生产消息 =&gt;  死信队列 =&gt; 队列 =&gt;消费者消费队列2中的消息</p>
<p><strong>死信队列</strong> 中的消息经由==过期转发==到 <strong>队列</strong> 中 再由消费者消费</p>
</blockquote>
<p>消息的TTL</p>
<p>死信路由</p>
<h5 id="延迟队列实现代码">延迟队列实现代码</h5>
<pre><code class="language-java">package com.yangkeai.rabbitmq.utils;

import com.alibaba.fastjson.JSON;
import com.yangkeai.common.exception.MyException;
import com.yangkeai.rabbitMQ.config.RabbitMQConfig;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeoutException;

/**
 * MQ工具类
 *
 * @author yang yang
 * @create 2018/9/12
 * @since 1.0.0
 */
public class RabbitMQUtils {

    /**
     * 获取连接
     *
     * @return
     */
    public static Connection getConnection() {
        ConnectionFactory factory = new ConnectionFactory();

        factory.setHost(RabbitMQConfig.HOST);
        factory.setPort(RabbitMQConfig.PORT);
        factory.setUsername(RabbitMQConfig.USERNAME);
        factory.setPassword(RabbitMQConfig.PASSWORD);
        factory.setConnectionTimeout(RabbitMQConfig.CONNECTIONTIMEOUT);
        factory.setShutdownTimeout(RabbitMQConfig.SHUTDOWNTIMEOUT);

        try {
            return factory.newConnection();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }

        throw new MQException(&quot;获取连接失败&quot;);
    }

    /**
     * 获取channel对象
     *
     * @return
     */
    public static Channel getChannel() {
        Connection connection = getConnection();
        try {
            return connection.createChannel();
        } catch (IOException e) {
            e.printStackTrace();
        }
        throw new MQException(&quot;创建Channel失败&quot;);
    }

    /**
     * 发送即时消息
     *
     * @param exchangeName 交换机
     * @param queueName    队列名称
     * @param payload      消息体
     */
    public static void send(String exchangeName, String queueName, Object payload) {
        Channel channel = getChannel();
        try {
            channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT);
            channel.queueDeclare(queueName, true, false, false, null);
            channel.queueBind(queueName, exchangeName, queueName);

            channel.confirmSelect();
            channel.basicPublish(exchangeName, queueName, true,
                    new AMQP.BasicProperties
                            .Builder()
                            .contentType(&quot;application/json&quot;)
                            .contentEncoding(&quot;UTF-8&quot;)
                            .build(),
                    JSON.toJSONString(payload).getBytes());

            if (!channel.waitForConfirms()) {
                throw new MQException(&quot;发送消息失败&quot;);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            Connection connection = channel.getConnection();
            closeChannel(channel, connection);
        }
    }

    /**
     * 发送延时消息
     *
     * @param exchangeName  交换机
     * @param queueName     队列名称
     * @param deadQueueName 死信队列名称
     * @param payload       消息体
     * @param delayTime     延时时间
     */
    public static void sendDelay(String exchangeName, String queueName, String deadQueueName, Object payload, Long delayTime) {
        Channel channel = getChannel();
        try {
            //交换器|队列|死信队列 创建与关系绑定
            channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT);

            Map&lt;String, Object&gt; arguments = new HashMap&lt;&gt;();
            arguments.put(&quot;x-max-length&quot;, 10000);
            arguments.put(&quot;x-dead-letter-exchange&quot;, exchangeName);
            arguments.put(&quot;x-dead-letter-routing-key&quot;, queueName);
            channel.queueDeclare(deadQueueName, true, false, false, null);
            channel.queueDeclare(queueName, true, false, false, null);

            channel.queueBind(queueName, exchangeName, queueName);
            channel.queueBind(deadQueueName, exchangeName, deadQueueName);

            //开启发送
            channel.confirmSelect();
            //消息的发送
            channel.basicPublish(exchangeName, queueName, true,
                    new AMQP.BasicProperties
                            .Builder()
                            .contentType(&quot;application/json&quot;)
                            .contentEncoding(&quot;UTF-8&quot;)
                            .expiration(delayTime + &quot;&quot;)
                            .build(),
                    JSON.toJSONString(payload).getBytes());

            if (!channel.waitForConfirms()) {
                throw new MQException(&quot;发送消息失败&quot;);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            Connection connection = channel.getConnection();
            closeChannel(channel, connection);
        }
    }

    /**
     * get方式获取消息 对应的是
     *
     * @param queueName 队列名称
     * @return
     */
    public static String get(String queueName) {
        Channel channel = getChannel();

        try {
            channel.queueDeclare(queueName, true, false, false, null);

            channel.basicQos(1);
            GetResponse getResponse = channel.basicGet(queueName, false);
            if (null != getResponse &amp;&amp; null != getResponse.getEnvelope()) {
                channel.basicAck(getResponse.getEnvelope().getDeliveryTag(), false);
                return new String(getResponse.getBody());
            } else {
                throw new MQException(&quot;获取消息失败&quot;);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            Connection connection = channel.getConnection();
            closeChannel(channel, connection);
        }
        throw new MQException(&quot;获取消息失败&quot;);
    }

    /**
     * 消费者方式获取消息
     *
     * @param queueName 队列名称
     */
    public static void consume(String queueName) {
        final Channel channel = getChannel();

        try {
            channel.queueDeclare(queueName, true, false, false, null);

            channel.basicQos(1);

            Consumer consumer = new DefaultConsumer(channel) {
                @Override
                public void handleDelivery(String consumerTag,
                                           Envelope envelope,
                                           AMQP.BasicProperties properties,
                                           byte[] body)
                        throws IOException {

                    if (null != envelope) {
                        channel.basicAck(envelope.getDeliveryTag(), false);
                        System.out.println(&quot;队列中存储的消息 ：&quot; + new String(body));
                    }
                }
            };
            channel.basicConsume(queueName, consumer);

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                long count = channel.messageCount(queueName);
                if (count &lt;= 0) {
                    Connection connection = channel.getConnection();
                    closeChannel(channel, connection);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 关闭连接
     *
     * @param channel    当前通道
     * @param connection 当前连接
     */
    public static void closeChannel(Channel channel, Connection connection) {
        try {
            if (null != channel) {
                channel.close();
            }
            if (null != connection) {
                connection.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<pre><code class="language-java">package com.yangkeai.rabbitmq.config;

import lombok.Builder;
import lombok.Data;

/**
 * rabbitMQ相关的配置
 *
 * @author yang yang
 * @create 2018/9/12
 * @since 1.0.0
 */
@Data
@Builder
public class RabbitMQConfig {

    public static String HOST = &quot;127.0.0.1&quot;;
    public static int PORT = 5672;
    public static String USERNAME = &quot;guest&quot;;
    public static String PASSWORD = &quot;guest&quot;;
    public static int CONNECTIONTIMEOUT = 10_000;
    public static int SHUTDOWNTIMEOUT = 10_000;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA基础总结]]></title>
        <id>https://yangyng.github.io/post/c4zpXbVC3</id>
        <link href="https://yangyng.github.io/post/c4zpXbVC3">
        </link>
        <updated>2019-06-17T03:30:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java基础知识">JAVA基础知识</h2>
<h4 id="1-八种数据类型">1. 八种数据类型</h4>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>包装类</th>
<th>字节</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>double</td>
<td>Double</td>
<td>8位</td>
<td>0.0D</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>4位</td>
<td>0.0F</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>8位</td>
<td>1L</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>4位</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>2位</td>
<td>(short)1</td>
</tr>
<tr>
<td>byte</td>
<td>byte</td>
<td>1位</td>
<td>(byte)0</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>2位</td>
<td>null\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td>--</td>
<td>false</td>
</tr>
</tbody>
</table>
<h4 id="2引用数据类型">2.引用数据类型</h4>
<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
<h4 id="3switch是否可以使用string作为参数">3.Switch是否可以使用String作为参数</h4>
<p><strong>Jdk7.0 之前</strong> byte short char int 可以强转</br>
<strong>Jdk7.0 之后</strong> 整形 枚举类型 boolean 字符串都可以</p>
<h4 id="4equals与的区别">4.equals与==的区别</h4>
<blockquote>
<p>== 比较的是对象的地址 </br>
equals 比较的时间对象的内容</p>
</blockquote>
<h4 id="5自动装箱-常量池">5.自动装箱 ,常量池</h4>
<blockquote>
<p>自动装箱: 基本数据类型=&gt;对象类型</p>
<p>自动拆箱: 对象类型=&gt;基本数据类型</p>
</blockquote>
<blockquote>
<p>常量池:Byte Short Integer Long Character 在自动装箱时对于值从-128-127之间的值(共享),会在内存中被重用</p>
</blockquote>
<h4 id="6object有哪些公用方法">6.Object有哪些公用方法</h4>
<ul>
<li>clone()</li>
<li>hashCode()</li>
<li>equals()</li>
<li>notify()</li>
<li>wait()</li>
<li>notifyAll()</li>
<li>getClass()</li>
<li>toString()</li>
<li>finalize()</li>
</ul>
<h4 id="7java的四种引用">7.Java的四种引用</h4>
<ul>
<li>强引用: 使用普遍的引用,内存空间不住了,一般垃圾和回收期绝不会回收它</li>
<li>软引用: 弱引用可用来实现内存敏感的高速缓存,内存空间不足了,就会回收这些对象的内存</li>
<li>弱引用: 具有弱引用的对象,不管当前内存空间足够与否,都会回收它的内存</li>
<li>虚引用: 虚引用并不会决定对象的生命周期.如果一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收器回收</li>
</ul>
<h4 id="8hashcode的作用">8.HashCode的作用</h4>
<p>Java中的hashCode方法就是根据一定的规则将与对象相关的信息(对象的存储地址,对象的字段等)映射成一个数值,这个数值称作为散列值,降低equals的调用,实现存放的值不会重复</p>
<h4 id="9arraylist-linkedlist-vector的作用">9.ArrayList、LinkedList、Vector的作用</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">线程是否安全</th>
<th style="text-align:center">实现方式</th>
<th style="text-align:center">扩容</th>
<th style="text-align:center">适合</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ArrayList</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">自动扩容50%</td>
<td style="text-align:center">查找</td>
</tr>
<tr>
<td style="text-align:center">LinkedList</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center">链表</td>
<td style="text-align:center">删除</td>
<td style="text-align:center">插入</td>
</tr>
<tr>
<td style="text-align:center">Vector</td>
<td style="text-align:center">安全</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">自动扩容100%</td>
<td style="text-align:center">查找</td>
</tr>
</tbody>
</table>
<h4 id="10string-stringbuffer-stringbuilder">10.String StringBuffer StringBuilder</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">线程是否安全</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">对象信息</th>
<th style="text-align:center">适合</th>
<th style="text-align:center">补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">--</td>
<td style="text-align:center">final修饰的字符串常量</td>
<td style="text-align:center">String对象一旦创建之后是不可更改的</td>
<td style="text-align:center">--</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">StringBuffer</td>
<td style="text-align:center">安全</td>
<td style="text-align:center">字符串常量</td>
<td style="text-align:center">对象可变</td>
<td style="text-align:center">适合多线程下字符串缓冲区大量操作</td>
<td style="text-align:center">继承AbstractStringBuilder 容量为16</td>
</tr>
<tr>
<td style="text-align:center">StringBuilder</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center">字符串常量</td>
<td style="text-align:center">对象可变</td>
<td style="text-align:center">适合单线程下字符缓冲区大量操作</td>
<td style="text-align:center">继承AbstractStringBuilder 容量为16</td>
</tr>
</tbody>
</table>
<h4 id="11map-set-list-queue-stack的特点与用法">11.Map Set List Queue Stack的特点与用法</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">实现方式</th>
<th style="text-align:center">线程是否安全</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">是否有序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HashMap</td>
<td style="text-align:center">键值对</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center">不能存储null值</td>
<td style="text-align:center">无序</td>
</tr>
<tr>
<td style="text-align:center">HashTable</td>
<td style="text-align:center">键值对</td>
<td style="text-align:center">安全</td>
<td style="text-align:center">可以存储null值</td>
<td style="text-align:center">无序</td>
</tr>
<tr>
<td style="text-align:center">TreeMap</td>
<td style="text-align:center">键值对</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">有序</td>
</tr>
<tr>
<td style="text-align:center">ArrayList</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">LinkedList</td>
<td style="text-align:center">链表</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Vector</td>
<td style="text-align:center">数组</td>
<td style="text-align:center">安全</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Stack</td>
<td style="text-align:center">后进先出的栈</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="12collection与collections的区别">12.Collection与Collections的区别</h4>
<blockquote>
<p>Collection是各种集合结构的父接口</p>
<p>Collections包含有各种有关集合操作的静态方法</p>
</blockquote>
<h4 id="13trycatchfinally执行">13.try?catch?finally执行</h4>
<blockquote>
<p>finally 中的return也会执行 除非中途遇到JVM退出</p>
</blockquote>
<h4 id="14exception和error">14.Exception和Error</h4>
<blockquote>
<p>两者都是Throwable的子类</p>
<p>Exception 之处了合理的应用程序想要捕获的条件</p>
<p>Error用于只是合理的应用程序不应该视图捕获的严重问题.大多数这样的错误都是异常条件</p>
</blockquote>
<p>OOM中</p>
<ul>
<li>Java heap溢出</li>
<li>虚拟机栈和本地方法栈溢出</li>
<li>运行时常量池溢出</li>
<li>方法溢出</li>
</ul>
<p>SOF(StackOverflowError) 当应用程序递归太深发生堆栈溢出时,抛出该错误</p>
<h4 id="15oop的三个特征和含义">15.OOP的三个特征和含义</h4>
<blockquote>
<p>封装: 可见性封装,set get读写,将类的某些特征隐藏在类的内部,不允许外部程序直接访问,而是通过该类提供的方法来实现对隐藏信息的访问和操作</p>
</blockquote>
<blockquote>
<p>继承: 子类继承父类,可以得到父类的全部属性和方法(除了父类中的构造方法),JAVA中的多继承可以通过接口来实现</p>
</blockquote>
<blockquote>
<p>多态: 已是==编译时多态==,另外一种是==运行时多态==,==编译时多态==通过方法的重载来实现,==运行时多态==通过方法的重写来实现</p>
</blockquote>
<h4 id="16重载override和重写overload">16.重载(Override)和重写(Overload)</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">相同</th>
<th style="text-align:center">不同</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">重写(Override)</td>
<td style="text-align:center">子类覆盖父类的方法</br>子类抛出的异常不能超过父类响应方法抛出的异常</br>子类方法的访问级别不能低于弗雷响应方法的访问级别</td>
<td style="text-align:center">返回类型|参数|参数类型|抛出异常</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">重载(Overload)</td>
<td style="text-align:center"></td>
<td style="text-align:center">方法名</td>
<td style="text-align:center">参数个数|参数数量</td>
</tr>
</tbody>
</table>
<h4 id="17interface与abstract类的区别">17.interface与abstract类的区别</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">interface</th>
<th style="text-align:center">abstract</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">构造方法</td>
<td style="text-align:center">--</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">普通成员变量</td>
<td style="text-align:center">--</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">非抽象的普通方法</td>
<td style="text-align:center">--</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">静态方法</td>
<td style="text-align:center">--</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">静态成员变量</td>
<td style="text-align:center">只能切默认为public static final</td>
<td style="text-align:center">任意类型</td>
</tr>
<tr>
<td style="text-align:center">访问类型</td>
<td style="text-align:center">只能为public 默认为public abstract</td>
<td style="text-align:center">public protected</td>
</tr>
<tr>
<td style="text-align:center">继承与实现</td>
<td style="text-align:center">一个类可以实现多个接口</td>
<td style="text-align:center">单继承</td>
</tr>
</tbody>
</table>
<h4 id="18静态内部类和非静态内部类">18.静态内部类和非静态内部类</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">static class</th>
<th style="text-align:center">not static class</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">指向外部类的引用</td>
<td style="text-align:center">需要</td>
<td style="text-align:center">不需要</td>
</tr>
<tr>
<td style="text-align:center">描述</td>
<td style="text-align:center">可以访问外部类的静态成员==不能访问外部类的非静态成员==</td>
<td style="text-align:center">访问外部类的静态和非静态成员</td>
</tr>
</tbody>
</table>
<h4 id="19foreach和for">19.foreach和for</h4>
<blockquote>
<p>对于数组 相差不大</p>
</blockquote>
<blockquote>
<p>对于链表 for循环效率比foreach低</p>
</blockquote>
<h4 id="20io与nio">20.IO与NIO</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">IO</th>
<th style="text-align:center">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">是否阻塞</td>
<td style="text-align:center">阻塞</td>
<td style="text-align:center">非阻塞</td>
</tr>
<tr>
<td style="text-align:center">面向</td>
<td style="text-align:center">流</td>
<td style="text-align:center">缓冲区(块)</td>
</tr>
<tr>
<td style="text-align:center">描述</td>
<td style="text-align:center"></td>
<td style="text-align:center">管道(Channel) 缓冲(Buffer) 选择器(Selector)</td>
</tr>
<tr>
<td style="text-align:center">应用</td>
<td style="text-align:center">少连接 大数据</td>
<td style="text-align:center">多连接 少数据</td>
</tr>
</tbody>
</table>
<h4 id="21xml解析方式">21.XML解析方式</h4>
<blockquote>
<p><strong>DOM:</strong> 将整个XML文档转化成DOM树存放在内存中</p>
</blockquote>
<blockquote>
<p><strong>SAX:</strong> 采用事件驱动,通过事件处理函数实现对XML文档的访问</p>
</blockquote>
]]></content>
    </entry>
</feed>